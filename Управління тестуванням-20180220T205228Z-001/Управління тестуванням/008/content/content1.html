<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Аналіз вимог до інформаційних систем — Теорія — Оєктно-орієнтована модель програмної системи.  Розробка діаграми послідовності</title><script language="javascript" type="text/javascript" src="../../000/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../000/styles/files/sco.js"> </script><link href="../../000/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../000/content/authors1.html">Автори</a></li><li>|</li><li><a href="../../000/content/contacts1.html">Контакти</a></li><li>|</li><li><a href="../../000/content/help-system1.html">Підсистема допомоги</a></li><li>|</li><li><a href="../../000/content/instructions1.html">Методичні вказівки</a></li><li>|</li><li><a href="../../000/content/annotation1.html">Анотація</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Аналіз вимог до інформаційних систем</div><div id="courseSubTitle">Лабораторний практикум №5 - О’єктно-орієнтована модель програмної системи.  Розробка діаграми послідовності : Оєктно-орієнтована модель програмної системи.  Розробка діаграми послідовності</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../000/styles/courses.html">Зміст курсу</a></li><li><a href="../../008/content/preface1.html">Вступ</a></li><li><span>Теорія</span></li><ul class="level1"><li><a href="../../008/content/content1.html">Оєктно-орієнтована модель програмної системи.  Розробка діаграми послідовності</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../008/content/example1.html">Порядок виконання роботи</a></li></ul><li><a href="../../008/content/conclusion1.html">Висновки</a></li><li><a href="../../008/008.pdf" target="_blank">Версія для друку</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnka1591a5598154ba79ad7d4c66ccc9b1c"> </span><h1 align="left" class="headline-source">Оєктно-орієнтована модель програмної системи.  Розробка діаграми послідовності</h1><span id="lnk78246b64ef7d43fca85b1a86b0a273b7"> </span><h2 align="left" class="paragraph-headline-source">Методичні рекомендації до самостійної роботи студентів</h2><span id="lnkf0e716438a854b8d90feaa9615940b62"> </span><div class="section"><p align="justify" class="paragraph-source">     Для моделювання взаємодії об'єктів в мові UML використовуються відповідні діаграми взаємодії. Говорячи про ці діаграми, мають на увазі два аспекти взаємодії. По-перше, взаємодії об'єктів можна розглядати в часі, і тоді для представлення тимчасових особливостей передачі і прийому повідомлень між об'єктами використовується діаграма послідовності. Часовий аспект поведінки може мати істотне значення при моделюванні синхронних процесів, що описують взаємодії об'єктів. Саме для цієї мети в мові UML використовуються діаграми послідовності.</p><p align="justify" class="paragraph-source">     По-друге, можна розглядати структурні особливості взаємодії об'єктів. Для представлення структурних особливостей передачі і прийому повідомлень між об'єктами використовується діаграма кооперації.</p><p align="justify" class="paragraph-source">     На діаграмі послідовності зображуються виключно ті об'єкти, які безпосередньо беруть участь у взаємодії і не показуються можливі статичні асоціації з іншими об'єктами. Для діаграми послідовності ключовим моментом є саме динаміка взаємодії об'єктів в часі. Крайнім ліворуч на діаграмі зображається об'єкт, який є ініціатором взаємодії (об'єкт 1 на рис.5.1). </p><p align="justify" class="paragraph-source">     Правіше зображається інший об'єкт, який безпосередньо взаємодіє з першим. Таким чином, усі об'єкти на діаграмі послідовності утворюють деякий порядок, визначуваний мірою активності цих об'єктів при взаємодії один з одним. Кожна взаємодія описується сукупністю повідомлень, якими об'єкти, що беруть участь в нім, обмінюються між собою. У цьому сенсі повідомлення<i> </i>(message) є закінченим фрагментом інформації, який вирушає одним об'єктом іншому. При цьому прийом повідомлення ініціює виконання певних дій, спрямованих на рішення окремої задачі тим об'єктом, якому це повідомлення відправлене.</p><p align="justify" class="paragraph-source">     Таким чином, повідомлення не лише передають деяку інформацію, але і вимагають або припускають від приймаючого об'єкту виконання очікуваних дій. Повідомлення можуть ініціювати виконання операцій об'єктом відповідного класу, а параметри цих операцій передаються разом з повідомленням. </p></div><span id="lnk98bd7e0f6db74b47822d686132e31492"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg275_0_.jpg" height="385px" width="507px" alt="" /> </p></div><span id="lnk3ad77fb7e20e417280a746857c1b8436"> </span><div class="section"><p align="justify" class="paragraph-source">     На діаграмі послідовності усі повідомлення впорядковані за часом свого виникнення в модельованій системі.</p><p align="justify" class="paragraph-source">     У мові UML можуть зустрічатися декілька різновидів повідомлень, кожне з яких має своє графічне зображення:</p><p align="justify" class="paragraph-source">     - перший різновид повідомлення є найбільш поширеним і використовується для виклику процедур, виконання операцій або позначення окремих вкладених потоків управління.</p><p align="justify" class="paragraph-source">     - другий різновид повідомлення використовується для позначення простого(не вкладеного) потоку управління.</p><p align="justify" class="paragraph-source">     - третій різновид явно означає асинхронне повідомлення між двома об'єктами в деякій процедурній послідовності. прикладом такого повідомлення може служити переривання операції при виникненні виняткової ситуації.</p><p align="justify" class="paragraph-source">     - нарешті, останній різновид повідомлення використовується для повернення з виклику процедури. прикладом може служити просте повідомлення про завершення деяких обчислень без надання результату розрахунків об'єкту-клієнтові.</p><p align="justify" class="paragraph-source">     Повідомлення можуть мати власне позначення операції, виклик якої вони ініціюють у приймаючого об'єкту. В цьому випадку поряд із стрілкою записується ім'я операції з круглими дужками, в яких можуть вказуватися параметри або аргументи відповідної операції. Якщо параметри відсутні, то дужки все одно мають бути присутніми після імені операції. Прикладами таких операцій можуть служити наступні: "видати клієнтові готівкою суму(п)", "встановити з'єднання між абонентами", "зробити текст, що вводиться, невидимим () ", "подати звуковий сигнал тривоги ()".</p><p align="justify" class="paragraph-source">     Різні елементи логічного представлення, такі як класи, асоціації, стани, повідомлення, не існують матеріально або фізично. Вони лише відбивають наше розуміння структури фізичної системи або аспекти її поведінки. Для створення конкретної фізичної системи необхідно деяким чином реалізувати усі елементи логічного представлення в конкретні матеріальні сутності. Для опису таких реальних сутностей призначений інший аспект модельного представлення, а саме фізичне представлення моделі.</p><p align="justify" class="paragraph-source">     Щоб пояснити відмінність логічного і фізичного представлень, розглянемо у загальних рисах процес розробки деякої програмної системи. Її початковим логічним представленням можуть служити структурні схеми алгоритмів і процедур, описи інтерфейсів і концептуальні схеми баз даних. Проте для реалізації цієї системи необхідно розробити початковий текст програми на деякій мові програмування (C++, Pascal, Basic/VBA, Java). При цьому вже в тексті програми передбачається така організація програмного коду, яка припускає його розбиття на окремі модулі.</p><p align="justify" class="paragraph-source">     Проте, початкові тексти програми ще не є остаточною реалізацією проекту, хоча і служать фрагментом його фізичного представлення. Очевидно, програмна система може вважатися реалізованою у тому випадку, коли вона буде здатна виконувати функції свого цільового призначення. А це можливо, тільки якщо програмний код системи буде реалізований у формі виконуваних модулів, бібліотек класів і процедур, стандартних графічних інтерфейсів, файлах баз даних. Саме ці компоненти є необхідними елементами фізичного представлення системи.</p><p align="justify" class="paragraph-source">     Діаграма компонентів<i>,</i> на відміну від раніше розглянутих діаграм, описує особливості фізичного представлення системи. Діаграма компонентів дозволяє визначити архітектуру системи, що розробляється, встановивши залежності між програмними компонентами, в ролі яких може виступати початковий, бінарний і виконуваний код. Основними графічними елементами діаграми компонентів є компоненти, інтерфейси і залежності між ними (рис.5.2).</p><p align="justify" class="paragraph-source">     Діаграма компонентів розробляється для наступних цілей:</p><p align="justify" class="paragraph-source">     - візуалізація загальної структури початкового коду програмної системи;</p><p align="justify" class="paragraph-source">     - специфікації здійснимого варіанту програмної системи;</p><p align="justify" class="paragraph-source">     - забезпечення багатократного використання окремих фрагментів програмного коду;</p><p align="justify" class="paragraph-source">     - представлення концептуальної і фізичної схем баз даних.</p></div><span id="lnk5add8020fd3c42308d6f0081ee5bf0c4"> </span><div class="section"><p align="justify" class="paragraph-source">Для представлення фізичних сутностей в мові UML застосовується спеціальний термін - компонент (component)<i>.</i> Компонент реалізує деякий набір інтерфейсів і служить для загального позначення елементів фізичного представлення моделі.</p></div><span id="lnk13f930a4752c43ed99ed3a01ba5b94f0"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg277_0_.jpg" height="138px" width="400px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 5.2 -  Графічне зображення компонента в мові UML</p></div><span id="lnk76aac0a7067543d7a6c97cc016331f63"> </span><div class="section"><p align="justify" class="paragraph-source">     Ім'я компонента підкоряється загальним правилам іменування елементів моделі в мові UML і може складатися з будь-якого числа букв, цифр і деяких розділових знаків.</p><p align="justify" class="paragraph-source">     В якості простих імен прийнято використати імена виконуваних файлів(з вказівкою розширення ехе після точки-роздільника), імена динамічних бібліотек (розширення dll), імена Web- сторінок (розширення html), імена текстових файлів (розширення txt або doc) або файлів довідки(hip), імена файлів баз даних(DB) або імена файлів з початковими текстами програм (розширення h, cpp для мови C++, розширення Java для мови Java), скрипти(pi, asp) та ін.</p><p align="justify" class="paragraph-source">     У мові UML виділяють три види компонентів.</p><p align="justify" class="paragraph-source">     - компоненти розгортання, які забезпечують безпосереднє виконання системою своїх функцій. Такими компонентами можуть бути бібліотеки, що динамічно підключаються, з розширенням dll, web- сторінки на мові розмітки гіпертексту з розширенням html і файли довідки з розширенням hlp;</p><p align="justify" class="paragraph-source">     - компоненти-робітники продукти. як правило - це файли з початковими текстами програм, наприклад, з розширеннями h або срр для мови  c++;</p><p align="justify" class="paragraph-source">     - компоненти виконання, що представляють здійснимі модулі -файли з розширенням ехе.</p><p align="justify" class="paragraph-source">     Відношення залежності на діаграмі компонентів зображується пунктирною лінією із стрілкою, спрямованою від клієнта(залежного елементу) до джерела(незалежному елементу).</p><p align="justify" class="paragraph-source">     Залежності можуть відбивати зв'язки модулів програми на етапі компіляції і генерації об'єктного коду. У іншому випадку залежність може відбивати наявність в незалежному компоненті описів класів, які використовуються в залежному компоненті для створення відповідних об'єктів.</p></div><span id="lnk69263bab03074c039b30eb54eb767183"> </span><div class="section"><p align="justify" class="paragraph-source">     Так, наприклад, зображений нижче фрагмент діаграми компонентів уявляє інформацію про те, що компонент з ім'ям "main.exe" залежить від інтерфейсу "IDialog", що імпортується, який, у свою чергу, реалізується компонентом з ім'ям image java. Для другого компонента цей же інтерфейс є таким, що експортується.</p><p align="justify" class="paragraph-source">     На діаграмі компонентів можуть бути представлені стосунки залежності між компонентами і реалізованими в них класами. Ця інформація має важливе значення для забезпечення узгодження логічного і фізичного представлень моделі системи. Зрозуміло, зміни в структурі описів класів можуть привести до зміни компонента. Нижче наводиться фрагмент залежності подібного роду, коли деякий компонент залежить від відповідних класів. До початку розробки необхідно прийняти рішення про вибір обчислювальних платформ і операційних систем, на яких передбачається реалізовувати систему, а також про вибір конкретних баз даних і мов програмування.</p><p align="justify" class="paragraph-source">     Після цього можна приступати до загальної структуризації діаграми компонентів. В першу чергу, необхідно вирішити, з яких фізичних частин(файлів) складатиметься програмна система.</p><p align="justify" class="paragraph-source">     Після загальної структуризації фізичного представлення системи необхідно доповнити модель інтерфейсами і схемами бази даних. Включення в модель схеми бази даних припускає специфікацію окремих таблиць і встановлення інформаційних зв'язків між таблицями.</p><p align="justify" class="paragraph-source">     Нарешті, завершальний етап побудови діаграми компонентів пов'язаний зі встановленням і нанесенням на діаграму взаємозв'язків між компонентами, а також стосунків реалізації. Ці стосунки повинні ілюструвати усі найважливіші аспекти фізичної реалізації системи, починаючи з особливостей компіляції початкових текстів програм і закінчуючи виконанням окремих частин програми на етапі її виконання.</p><p align="justify" class="paragraph-source">     Діаграма розгортання призначена для візуалізації елементів і компонентів програми, існуючих лише на етапі її виконання (runtime). При цьому видаються тільки компоненти-екземпляри програми, що є здійснимими файлами або динамічними бібліотеками. Ті компоненти, які не використовуються на етапі виконання, на діаграмі розгортання не показуються. Так, компоненти з початковими текстами програм можуть бути присутніми тільки на діаграмі компонентів. На діаграмі розгортання вони не вказуються.</p><p align="justify" class="paragraph-source">     Діаграма розгортання містить графічні зображення процесорів, пристроїв, процесів і зв'язків між ними. На відміну від діаграм логічного представлення, діаграма розгортання є єдиною для системи в цілому, оскільки повинна цілком відбивати особливості її реалізації.</p><p align="justify" class="paragraph-source">     Цілі, що переслідуються при розробці діаграми розгортання:</p><p align="justify" class="paragraph-source">     - визначити розподіл компонентів системи по її фізичних вузлах;</p><p align="justify" class="paragraph-source">     - показати фізичні зв'язки між усіма вузлами реалізації системи на етапі її виконання;</p><p align="justify" class="paragraph-source">     - виявити вузькі місця системи і реконфігурувати її топологію для досягнення необхідної продуктивності.</p><p align="justify" class="paragraph-source">     Вузол (node) є деяким фізично існуючим елементом системи, що має деякий обчислювальний ресурс. В якості обчислювального ресурсу вузла може розглядатися наявність, щонайменше, деякого об'єму електронної або магнітооптичної пам'яті і/або процесора. У останній версії мови UML поняття вузла розширене і може включати не лише обчислювальні пристрої(процесори), але і інші механічні або електронні пристрої, такі як датчики, принтери, модеми, цифрові камери, сканери і маніпулятори.</p><p align="justify" class="paragraph-source">     Окрім власне зображень вузлів на діаграмі розгортання вказуються стосунки між ними. Стосунками виступають фізичні з'єднання між вузлами і залежності між вузлами і компонентами, зображення яких теж можуть бути присутніми на діаграмах розгортання. </p><p align="justify" class="paragraph-source">     <i>З'єднання</i> є різновидом асоціації і зображуються відрізками ліній без стрілок. Наявність такої лінії вказує на необхідність організації фізичного каналу для обміну інформацією між відповідними вузлами. Характер з'єднання може бути додатково специфікований приміткою, поміченою значенням або обмеженням.</p><p align="justify" class="paragraph-source">     Окрім з'єднань на діаграмі розгортання можуть бути присутніми стосунки залежності між вузлом і розгорнутими на нім компонентами. </p></div><span id="lnkc5e287d6ca6249b1b8d456aa508881e4"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg279_0_.jpg" height="144px" width="451px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 5.3 -  Фрагмент діаграми компонентів з відношеннямзалежності</p></div><span id="lnk5e61de4ad46146ea9b579a58c363b6cb"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg27d_0_.jpg" height="196px" width="464px" alt="" /> </p></div><span id="lnke86d65f928064c8c96c1b9281b32eb93"> </span><div class="section"><p align="justify" class="paragraph-source">     Подібний спосіб є альтернативою вкладеному зображенню компонентів усередині символу вузла, що не завжди зручно, оскільки робить цей символ надмірно об'ємним. Тому при великій кількості розгорнутих на вузлі компонентів відповідну інформацію можна представити у формі відношення залежності (рис. 5.5).</p></div><span id="lnk21733df4d86a42a1b8a49de89cfbb0ed"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg27f_0_.jpg" height="219px" width="532px" alt="" /> </p></div><span id="lnkdc7aa13244194baa955bf0d1e6cb5b05"> </span><div class="section"><p align="justify" class="paragraph-source">     Діаграми розгортання можуть мати складнішу структуру, що включає вкладені компоненти, інтерфейси і інші апаратні пристрої. На зображеній нижче діаграмі розгортання представлений фрагмент фізичного представлення системи видаленого обслуговування клієнтів банку. Вузлами цієї системи є видалений термінал(вузол-тип) і сервер банку(вузол-екземпляр).</p><p align="justify" class="paragraph-source">     Розробка діаграми розгортання розпочинається з ідентифікації усіх апаратних, механічних і інших типів пристроїв, які потрібні для виконання системою усіх своїх функцій. В першу чергу специфікуються обчислювальні вузли системи, що мають пам'ять і/або процесор.</p><p align="justify" class="paragraph-source">     Подальша побудова діаграми розгортання пов'язана з розміщенням усіх виконуваних компонентів діаграми по вузлах системи. Якщо окремі виконувані компоненти виявилися не розміщеними, то подібна ситуація має бути виключена введенням в модель додаткових вузлів, що містять процесор і пам'ять.</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2010 ХНУРЕ, ПЗЕОМ, Шатовська Т. Б., <a href="mailto:shatovska@gmail.com">shatovska@gmail.com</a>;   ХНУРЕ, ПЗЕОМ, Репка В. Б., <a href="mailto:victoria_repka@kture.kharkov.ua">victoria_repka@kture.kharkov.ua</a><br /><a href="http://lersus.de/" title="Цей курс створено за допомогою авторської системи LERSUS" target="_blank">Розроблено за допомогою LERSUS</a></div></td></tr></table></td></tr></table></body></html>