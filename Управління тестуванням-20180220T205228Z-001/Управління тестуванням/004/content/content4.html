<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Аналіз вимог до інформаційних систем — Теорія — Розробка діаграми послідовності</title><script language="javascript" type="text/javascript" src="../../000/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../000/styles/files/sco.js"> </script><link href="../../000/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../000/content/authors1.html">Автори</a></li><li>|</li><li><a href="../../000/content/contacts1.html">Контакти</a></li><li>|</li><li><a href="../../000/content/help-system1.html">Підсистема допомоги</a></li><li>|</li><li><a href="../../000/content/instructions1.html">Методичні вказівки</a></li><li>|</li><li><a href="../../000/content/annotation1.html">Анотація</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Аналіз вимог до інформаційних систем</div><div id="courseSubTitle">Лекція 3. Специфікація вимог. : Розробка діаграми послідовності</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../000/styles/courses.html">Зміст курсу</a></li><li><span>Теорія</span></li><ul class="level1"><li><a href="../../004/content/content1.html">Шаблони спеціфікації вимог: proposal for development, SRS, бізнес вимоги.</a></li><li><a href="../../004/content/content2.html">Розробка варіантів використання (UML), робота з бізнес правилами.</a></li><li><a href="../../004/content/content3.html">Розробка інформаційної моделі системи. Аналіз інформаційних потоків в системі та їх представлення. DFD-діаграми. Специфікація процесу.</a></li><li><a href="../../004/content/content4.html">Розробка діаграми послідовності</a></li><li><a href="../../004/content/content5.html">Розробка діаграми становища</a></li><li><a href="../../004/content/content6.html">Обєктно-орієнтована модель програмної системи.  Розробка діаграми класів.</a></li><li><a href="../../004/content/content7.html">Узгодження вимог та керування рисками</a></li><li><a href="../../004/content/content8.html">Agile процеси. </a></li><li><a href="../../004/content/content9.html">Моделі удосконалення вимог та технологічних процесів.</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../004/content/example1.html">Практичне завдання з теми продакт та спрінт беклог продукта</a></li><li><a href="../../004/content/example2.html"> Практична робота з теми розробка варіантів використання</a></li><li><a href="../../004/content/example3.html">Практичне завдання з теми розробка діаграми діяльності  </a></li><li><a href="../../004/content/example4.html">Практична робота з теми розробка діаграми послідовності</a></li><li><a href="../../004/content/example5.html">Практична робота з теми обєктно-орієнтована модель програмної системи.  Розробка діаграми класів</a></li></ul><li><a href="../../004/004.pdf" target="_blank">Версія для друку</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk44d136c117d74978a25982574d9baf53"> </span><h1 align="left" class="headline-source">Розробка діаграми послідовності</h1><span id="lnkbe8f36b5c01844029dfb5f884e5ba029"> </span><h2 align="left" class="paragraph-headline-source">Диаграма послідовності (sequence diagram)</h2><span id="lnkac135dc53dcb483d8bd8a624d6e76626"> </span><div class="section"><p align="justify" class="paragraph-source">     Однією з характерних особливостей систем різної природи і призначення є взаємодія між собою окремих елементів, з яких утворені ці системи. Йдеться про тому, що різні складові елементи систем не існують ізольовано, а роблять 'певний вплив один на одного, що і відрізняє систему як цілісне утворення від простої сукупності елементів. У мові UML взаємодія елементів розглядається в інформаційному аспекті їх комунікації, тобто взаємодіючі об'єкти обмінюються між собою деякою інформацією. При цьому інформація набуває форми закінчених повідомлень. Іншими словами, хоча повідомлення і має інформаційний вміст, воно набуває додаткової властивості робити направлений вплив на свого одержувача. Це повністю узгоджується з принципами ООАП, коли будь-які види інформаційної взаємодії між елементами системи мають бути зведені до відправки і прийому повідомлень між ними.</p><p align="justify" class="paragraph-source">     Для моделювання взаємодії об'єктів в мові UML використовуються відповідні діаграми взаємодії. Кажучи про ці діаграми, мають на увазі два аспекти взаємодії. По-перше, взаємодії об'єктів можна розглядати в часі, і тоді для представлення тимчасових особливостей передачі і прийому повідомлень між об'єктами використовується діаграма послідовності. Цей вигляд канонічних діаграм є предметом вивчення справжньої глави.</p><p align="justify" class="paragraph-source">Раніше, при вивченні діаграм стану і діяльності, було відмічено одну важливу обставину. Хоча розглянуті діаграми і використовуються для специфікації динаміки поведінки систем, час в явному вигляді в них не присутній. Проте часовий аспект поведінки може мати істотне значення при моделюванні синхронних процесів, що описують взаємодії об'єктів. Саме для цієї мети в мові UML використовуються діаграми послідовності.</p><p align="justify" class="paragraph-source">     По-друге, можна розглядати структурні особливості взаємодії об'єктів. Для представлення структурних особливостей передачі і прийому повідомлень між об'єктами використовується діаграма кооперації. </p></div><span id="lnke354b62b27ad4f0f81ccb824da72022d"> </span><h2 align="left" class="paragraph-headline-source">Об'єкти</h2><span id="lnk1e16bb81b2484944b00481cbe2e99750"> </span><div class="section"><p align="justify" class="paragraph-source">     На діаграмі послідовності зображаються виключно ті об'єкти, які безпосередньо беруть участь у взаємодії і не показуються можливі статичні асоціації з іншими об'єктами. Для діаграми послідовності ключовим моментом є саме динаміка взаємодії об'єктів в часі. При цьому діаграма послідовності має як би два виміри. Одне - зліва направо у вигляді вертикальних ліній, кожна з яких змальовує лінію життя окремого об'єкту, що бере участь у взаємодії. Графічно кожен об'єкт зображається прямокутником і розташовується у верхній частині своєї лінії життя. Усередині прямокутника записуються ім'я об'єкту і ім'я класу, розділені двокрапкою. При цьому весь запис підкреслюється, що є ознакою об'єкту, який, як відомо, є екземпляр класу.</p></div><span id="lnk65219b236b064c2e899a328eef65b1bc"> </span><div class="section"><p align="justify" class="paragraph-source">     Не виключається ситуація, коли ім'я об'єкту може бути відсутнім на діаграмі послідовності. В цьому випадку вказується лише ім'я класу, а сам об'єкт вважається анонімним.</p></div><span id="lnk00b012666dfd4049aacf60d1bf2b1c5f"> </span><h2 align="left" class="paragraph-headline-source">Лінія життя об'єкту</h2><span id="lnkb2f4cb3f783349bb8db574f980d1caa8"> </span><div class="section"><p align="justify" class="paragraph-source">     Лінія життя об'єкту (object lifeline) зображається пунктирною вертикальною лінією, що асоціюється з єдиним об'єктом на діаграмі послідовності. Лінія життя служить для позначення періоду часу, протягом якого об'єкт існує в системі і, отже, може потенційно брати участь у всіх її взаємодіях. Якщо об'єкт існує в системі постійно, то і його лінія життя повинна продовжуватися по всій площині діаграми послідовності від самої верхньої її частини до самої нижньої.</p><p align="justify" class="paragraph-source">     Окремі об'єкти, виконавши свою роль в системі, можуть бути знищені (зруйновані), аби звільнити займані ними ресурси. Для таких об'єктів лінія життя обривається у момент його знищення. Для позначення моменту знищення об'єкту в мові UML використовується спеціальний символ у формі латинської букви «X». Нижче за цей символ пунктирна лінія не зображається, оскільки відповідного об'єкту в системі вже немає, і цей об'єкт має бути виключений зі всіх подальших взаємодій.Зовсім не обов'язково створювати всі об'єкти в початковий момент часу. Окремі об'єкти в системі можуть створюватися в міру необхідності, істотно економлячи ресурси системи і підвищуючи її продуктивність. В цьому випадку прямокутник такого об'єкту зображається не у верхній частині діаграми послідовності, а в тій її частині, яка відповідає моменту створення об'єкту. При цьому прямокутник об'єкту вертикально розташовується в тому місці діаграми, яке по осі часу збігається з моментом його виникнення в системі. Вочевидь, об'єкт обов'язково створюється зі своєю лінією життя і, можливо, з фокусом управління.</p></div><span id="lnk743383bbb92f410cbd5d0beed257fac0"> </span><h2 align="left" class="paragraph-headline-source">Фокус управління</h2><span id="lnkead0dca4d5b64395959ac7cdbc925a3d"> </span><div class="section"><p align="justify" class="paragraph-source">     В процесі функціонування об'єктно-орієнтованих систем одні об'єкти можуть знаходитися в активному стані, безпосередньо виконуючи певні дії або в стані пасивного чекання повідомлень від інших об'єктів. Аби явно виділити подібну активність об'єктів, в мові UML застосовується спеціальне поняття, що отримало назву фокусу управління (focus of control). Фокус управління зображається у формі витягнутого вузького прямокутника, верхня сторона якого позначає початок здобуття фокусу управління об'єкту (початок активності), а її нижня сторона - закінчення фокусу управління (закінчення активності). Цей прямокутник мається в своєму розпорядженні нижчим за позначення відповідного об'єкту і може замінювати його лінію життя, якщо на всьому її протязі він є активним.</p><p align="justify" class="paragraph-source">     З іншого боку, періоди активності об'єкту можуть чергуватися з періодами його пасивності або чекання. В цьому випадку в такого об'єкту є декілька фокусів управління. Поважно розуміти, що отримати фокус управління може лише існуючий об'єкт, в якого у цей момент є лінія життя. Якщо ж деякий об'єкт був знищений, то знов виникнути в системі він вже не може. Замість нього лише може бути створений інший екземпляр цього ж класу, який, строго кажучи, буде іншим об'єктом.</p><p align="justify" class="paragraph-source">     В окремих випадках ініціатором взаємодії в системі може бути актор або зовнішній користувач. В цьому випадку актор зображається на діаграмі послідовності найпершим об'єктом зліва зі своїм фокусом управління. Найчастіше актор і його фокус управління існуватимуть в системі постійно, відзначаючи характерну для користувача активність в ініціації взаємодій з системою. При цьому сам актор може мати власне ім'я або залишатися анонімним.Інколи деякий об'єкт може ініціювати рекурсивну взаємодію з самим собою. Йдеться про тому, що наявність в багатьох мовах програмування спеціальних засобів побудови рекурсивних процедур вимагає візуалізації відповідних понять у формі графічних примітивів. На діаграмі послідовності рекурсія позначається невеликим прямокутником, приєднаним до правої сторони фокусу управління того об'єкту, для якого зображається ця рекурсивна взаємодія</p></div><span id="lnkf3d8e79e782d49be81977683ca5aa175"> </span><h2 align="left" class="paragraph-headline-source">Повідомлення</h2><span id="lnkf64a0b2ea5b84a2e83bb93e7846b3c21"> </span><div class="section"><p align="justify" class="paragraph-source">     Як було відмічено вище, мета взаємодії в контексті мови UML полягає в тому, аби специфікувати комунікацію безліччю взаємодіючих об'єктів. Кожна взаємодія описується сукупністю повідомлень, якими об'єкти, що беруть участь в нім, обмінюються між собою. У цьому сенсі повідомлення (message) є закінченим фрагментом інформації, який вирушає одним об'єктом іншому. При цьому прийом повідомлення ініціює виконання певних дій, направлених на рішення окремої задачі тим об'єктом, якому це повідомлення відправлене.</p><p align="justify" class="paragraph-source">     Таким чином, повідомлення не лише передають деяку інформацію, але і вимагають або передбачають від приймаючого об'єкту виконання очікуваних дій. Повідомлення можуть ініціювати виконання операцій об'єктом відповідного класу, а параметри цих операцій передаються разом з повідомленням. На діаграмі послідовності всі повідомлення впорядковані за часом свого виникнення в модельованій системі.</p><p align="justify" class="paragraph-source">     У такому контексті кожне повідомлення має напрям від об'єкту, який ініціює і відправляє повідомлення, до об'єкту, який його отримує. Інколи відправника повідомлення називають клієнтом, а одержувача - сервером. При цьому повідомлення від клієнта має форму запиту деякого сервісу, а реакція сервера на запит після здобуття повідомлення може бути пов'язана з виконанням певних дій або передачі клієнтові необхідної інформації теж у формі повідомлення.</p></div><span id="lnkf39abe768b34469895aa78bf169acc62"> </span><h2 align="left" class="paragraph-headline-source">Галуження потоку управління</h2><span id="lnk7562c8e1ce6c43f38b7a6621cbcb41a1"> </span><div class="section"><p align="justify" class="paragraph-source">     Для зображення галуження малюються дві або більш стрілки, що виходять з однієї точки фокусу управління об'єкту (фокус управління об'єкту 1 на мал. 8.5). При цьому відповідні умови мають бути явно вказані поряд з кожною із стрілок у формі сторожової умови. Як неважко представити, якщо умова записана у формі булевого вираження, то галуження міститиме лише дві гілки. В будь-якому разі умови повинні взаємно виключати одночасну передачу альтернативних повідомлень.</p><p align="justify" class="paragraph-source">     За допомогою галуження можна змалювати і складнішу логіку взаємодії об'єктів між собою (фокус управління об'єкту 1 на мал. 8.6). Якщо умов більше двох, то для кожного з них необхідно передбачити ситуацію єдиного виконання. Даний приклад відноситься до моделювання взаємодії програмної системи обслуговування клієнтів в банці. На цьому прикладі діаграми послідовності об'єкт 1 передає управління одному з трьох інших об'єктів</p></div><span id="lnk9faa9afb4da541feb580bf3eafd0d2bf"> </span><h2 align="left" class="paragraph-headline-source">Приклад побудови діаграми послідовності</h2><span id="lnk9a3914b0884040b8b06be9b0540ae8fc"> </span><div class="section"><p align="justify" class="paragraph-source">     Як приклад розглянемо побудову діаграми послідовності для моделювання процесу телефонної розмови з використанням звичайної телефонної мережі. Об'єктами в даному прикладі є: два абоненти а і Ь, два телефонні апарати end, комутатор і сама розмова як об'єкт моделювання. При цьому як комутатор, так і розмова є анонімними об'єктами.На першому етапі розташовуємо вибрані об'єкти на передбачуваній діаграмі. Відмітимо, що абонентів ми розглядатимемо як акторів, причому перший з них - а - грає активну роль, а другий - b - пасивну роль. Тому перший отримує фокус управління відразу після своєї появи в системі, а другою має лише лінію життя. Комутатор також має постійну активність, що зображається його фокусом управління. Розмова як об'єкт з'являється лише після установки з'єднання і знищується з його припиненням. Тому він буде змальований пізнішим на цій же діаграмі послідовності.</p><p align="justify" class="paragraph-source">     Процес взаємодії в цій системі починається з піднімання трубки телефонного апарату першим абонентом. Тим самим він посилає повідомлення телефонного апарату з, яке переводить цей апарат в активний стан і викликає дію - подачу тонового сигналу в телефонну трубку для першого абонента. Наступна дія також ініціюється першим абонентом - набір цифр телефонного номера. Це представлено у формі ітеративного повідомлення із знаком "*" зліва від його імені.</p><p align="justify" class="paragraph-source">     Відмітимо, що піднімання телефонної трубки і набір цифр номера є фізичними діями і тому зображаються у формі простих асинхронних повідомлень. Після набору цифр'номера телефону апарат з рекурсивно викликає процедуру посилки комутаційних імпульсів на комутатор. Останній ініціює створення нового об'єкту в модельованій системі - телефонної розмови. Після створення анонімний об'єкт «розмова» відразу отримує фокус активності і посилає повідомлення телефонного апарату d на виконання дії - дзвінка виклику. При цьому другий абонент знімає трубку (асинхронне повідомлення), тим самим встановлюється пряме з'єднання між абонентами а і Ь. После того як абоненти опустять трубки, розмова закінчується. Тим самим об'єкт «розмова» знищується. Остаточний варіант діаграми послідовності може містити деякі тимчасові обмеження і коментарі. Призначення окремих повідомлень відповідають розглянутим діям.</p></div><span id="lnk749f2783671b4cc483989cc3d5fca8a1"> </span><h2 align="left" class="paragraph-headline-source">Завершальні рекомендації по побудові діаграм послідовності</h2><span id="lnk045dd9b83f66466daa70c7fedc10f823"> </span><div class="section"><p align="justify" class="paragraph-source">     Як вже наголошувалося, побудову діаграми послідовності доцільно починати з виділення зі всієї сукупності тих і лише тих класів, об'єкти яких беруть участь в модельованій взаємодії. Після цього всі об'єкти наносяться на діаграму з дотриманням деякого порядку ініціалізації повідомлень. Тут необхідно встановити, які об'єкти існуватимуть постійно, а які тимчасово - лише на період виконання ними необхідних дій.</p><p align="justify" class="paragraph-source">     Коли об'єкти візуалізовані, можна приступати до специфікації повідомлень. При цьому слід враховувати ті ролі, які грають повідомлення в системі. При необхідності уточнення цих ролей треба використовувати їх різновиди і стереотипи. Для знищення об'єктів, які створюються на час виконання своїх дій, потрібно передбачити явне повідомлення.</p><p align="justify" class="paragraph-source">     Найбільш прості випадки галуження процесу взаємодії можна змалювати на одній діаграмі з використанням відповідних графічних примітивів. Проте слід пам'ятати, що кожен альтернативний потік управління може істотно утруднити розуміння побудованої моделі. Тому загальним правилом є візуалізація кожного потоку управління на окремій діаграмі послідовності. У цій ситуації такі окремі діаграми повинні розглядатися спільно як одна модель взаємодії.</p><p align="justify" class="paragraph-source">     Подальша деталізація діаграми послідовності пов'язана з введенням тимчасових обмежень на виконання окремих дій в системі. Для простих асинхронних повідомлень тимчасові обмеження можуть бути відсутніми. Проте необхідність синхронізувати складні потоки управління, як правило, вимагають введення в модель таких обмежень. Загальний їх запис повинен слідувати семантиці мови об'єктних обмежень, яка розглянута в додатку.</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2010 ХНУРЕ, ПХЕОМ, Шатовська Т. Б., <a href="mailto:shatovska@gmail.com">shatovska@gmail.com</a><br /><a href="http://lersus.de/" title="Цей курс створено за допомогою авторської системи LERSUS" target="_blank">Розроблено за допомогою LERSUS</a></div></td></tr></table></td></tr></table></body></html>