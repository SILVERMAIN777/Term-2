<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Аналіз вимог до інформаційних систем — Теорія — Обєктно-орієнтована модель програмної системи.  Розробка діаграми класів та діаграми станів</title><script language="javascript" type="text/javascript" src="../../000/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../000/styles/files/sco.js"> </script><link href="../../000/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../000/content/authors1.html">Автори</a></li><li>|</li><li><a href="../../000/content/contacts1.html">Контакти</a></li><li>|</li><li><a href="../../000/content/help-system1.html">Підсистема допомоги</a></li><li>|</li><li><a href="../../000/content/instructions1.html">Методичні вказівки</a></li><li>|</li><li><a href="../../000/content/annotation1.html">Анотація</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Аналіз вимог до інформаційних систем</div><div id="courseSubTitle">Лабораторний практикум №4 - Об’єктно-орієнтована модель програмної системи.  Розробка діаграми класів та діаграми станів : Обєктно-орієнтована модель програмної системи.  Розробка діаграми класів та діаграми станів</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../000/styles/courses.html">Зміст курсу</a></li><li><a href="../../007/content/preface1.html">Вступ</a></li><li><span>Теорія</span></li><ul class="level1"><li><a href="../../007/content/content1.html">Обєктно-орієнтована модель програмної системи.  Розробка діаграми класів та діаграми станів</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../007/content/example1.html">Порядок виконання роботи</a></li></ul><li><a href="../../007/content/conclusion1.html">Висновки</a></li><li><a href="../../007/007.pdf" target="_blank">Версія для друку</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk208f590c627446e4ae39f59dec5659d7"> </span><h1 align="left" class="headline-source">Обєктно-орієнтована модель програмної системи.  Розробка діаграми класів та діаграми станів</h1><span id="lnk60df02c5eb6744f79702a95fd4f8bd88"> </span><h2 align="left" class="paragraph-headline-source">Методичні рекомендації до самостійної роботи студентів</h2><span id="lnkb9158cb431624a6da60a355320390c1a"> </span><div class="section"><p align="justify" class="paragraph-source">     Центральне місце в ООАП займає розробка логічної моделі системи у вигляді діаграми класів. Нотація класів в мові UML проста і інтуїтивно зрозуміла усім, хто коли-небудь мав досвід роботи з CASE- інструментаріями.</p><p align="justify" class="paragraph-source">     Діаграма класів (class diagram) служить для представлення статичної структури моделі системи в термінології класів об'єктно-орієнтованого програмування. Діаграма класів може відбивати, зокрема, різні взаємозв'язки між окремими сутностями предметної області, такими як об'єкти і підсистеми, а також описує їх внутрішню структуру і типи стосунків. На цій діаграмі не вказується інформація про тимчасові аспекти функціонування системи. З цієї точки зору діаграма класів є подальшим розвитком концептуальної моделі проектованої системи.</p></div><span id="lnkd7722bf1f7bb406fad2f9325f6421f6c"> </span><div class="section"><p align="justify" class="paragraph-source">     Клас<i> </i>(class) в мові UML служить для позначення безлічі об'єктів, які мають однакову структуру, поведінку і стосунки з об'єктами з інших класів. Графічно клас зображується у вигляді прямокутника, який додатково може бути розділений горизонтальними лініями на розділи або секції (рис. 4.1). У цих розділах можуть вказуватися ім'я класу, атрибути (змінні) і операції(методи). Позначаються простим прямокутником з вказівкою тільки імені відповідного класу. У міру опрацювання окремих компонентів діаграми опису класів доповнюються атрибутами і операціями</p></div><span id="lnkb3ceed283c0145708d9043805aec16d1"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg24b_0_.jpg" height="162px" width="395px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 4.1-  Графічне зображення класу на діаграмі класів</p></div><span id="lnk6f7eb7ce20c04ebcb0d4d99c02bbfe0e"> </span><div class="section"><p align="justify" class="paragraph-source">     Навіть якщо секція атрибутів або операцій є порожньою, в позначенні класу вона виділяється горизонтальною лінією, щоб відразу відрізнити клас від інших елементів мови UML. Для класу "Рахунок"(мал. 8, в) додатково зображена четверта секція, в якій вказано виключення, - відмова від обробки простроченої кредитної картки.</p><p align="justify" class="paragraph-source">     Ім'я класу має бути унікальним в межах пакету, який описується деякою сукупністю діаграм класів(можливо, однією діаграмою). На додаток до загального правила найменування елементів мови UML, ім'я класу записується по центру секції імені напівжирним шрифтом і повинно розпочинатися із заголовної букви. Рекомендується в якості імен класів використати іменники, записані з практичних міркувань без пропусків. Необхідно пам'ятати, що саме імена класів утворюють словник предметної області при ООАП.</p><p align="justify" class="paragraph-source">     Прикладами імен класів можуть бути такі іменники, як "Співробітник", "Компанія", "Керівник", "Клієнт", "Продавець", "Менеджер", "Офіс" і багато інших, що мають безпосереднє відношення до модельованої предметної області і функціонального призначення проектованої системи.</p><p align="justify" class="paragraph-source">     У другій згори секції прямокутника класу записуються його атрибути (attributes)<i> </i>або властивості. У мові UML прийнята певна стандартизація запису атрибутів класу, яка підкоряється деяким синтаксичним правилам. Кожному атрибуту класу відповідає окремий рядок тексту, який складається з квантора видимості атрибуту, імені атрибуту, його кратності, типу значень атрибуту і, можливо, його початкового значення :</p></div><span id="lnka504fe0dfb664136ab8b1e6ad3ae6a05"> </span><div class="section"><p align="justify" class="paragraph-source">     &lt;квантор видимості&gt; &lt;ім'я атрибуту&gt; [кратність] : &lt;тип атрибуту&gt; = &lt;початкове значення&gt; {рядок-властивість}</p></div><span id="lnk0b4a4d0072254fcb85121ea9394b7353"> </span><div class="section"><p align="justify" class="paragraph-source">     Квантор видимості може приймати одне з трьох можливих значень і, відповідно, відображається за допомогою спеціальних символів:</p><p align="justify" class="paragraph-source">     - символ   "+"   означає   атрибут   із   зоною   видимості типу загальнодоступний (public).</p><p align="justify" class="paragraph-source">     - символ   "#"   означає   атрибут   із   зоною   видимості типу захищений (protected).</p><p align="justify" class="paragraph-source">     - і, нарешті, знак "-" означає атрибут із зоною видимості типу закритий (private).</p><p align="justify" class="paragraph-source">     Квантор видимості може бути опущений. Ім'я атрибуту є рядком тексту, який використовується як ідентифікатор відповідного атрибуту і тому має бути унікальною в межах цього класу. Ім'я атрибуту є єдиним обов'язковим елементом синтаксичного позначення атрибуту. Тип атрибуту в нотації UML іноді визначається залежно від мови програмування, яку передбачається використати для реалізації цієї моделі. У простому випадку тип атрибуту вказується рядком тексту, що має осмислене значення в межах пакету або моделі, до яких відноситься даний клас. Початкове значення служить для завдання деякого початкового значення для відповідного атрибуту у момент створення окремого екземпляра класу.</p><p align="justify" class="paragraph-source">     Операція (operation) є деяким сервісом, який надає кожен екземпляр класу на певну вимогу. Сукупність операцій характеризує функціональний аспект поведінки класу. Запис операцій класу в мові UML також стандартизована і підкоряється певним синтаксичним правилам. При цьому кожній операції класу відповідає окремий рядок, який складається з квантора видимості операції, імені операції, вираз типу що повертає значення операції і, можливо, рядок-властивість цієї операції :</p></div><span id="lnk1247e717673148faae5546f7a37a1232"> </span><div class="section"><p align="justify" class="paragraph-source">     &lt;квантор видимості&gt; &lt;ім'я операції&gt; (список параметрів) : &lt;вираження типу повертаного значення&gt; { рядок-властивість}</p></div><span id="lnkf641f0ef853a42fe83ad18ebe1dc324e"> </span><div class="section"><p align="justify" class="paragraph-source">     Квантор видимості, як і у разі атрибутів класу, може приймати одне з трьох можливих значень і, відповідно, відображається за допомогою спеціального символу. Квантор видимості для операції може бути опущений. Ім'я операції є рядком тексту, який використовується як ідентифікатор відповідної операції і тому має бути унікальною в межах цього класу. Ім'я операції є єдиним обов'язковим елементом синтаксичного позначення операції. Список параметрів є переліком розділених комою формальних параметрів. Вираження типу повертаного значення також є залежною від мови реалізації специфікацією типу або типів значень параметрів, які повертаються об'єктом після виконання відповідної операції. Двокрапка і вираження типу повертаного значення можуть бути опущені, якщо операція не повертає ніякого значення.</p><p align="justify" class="paragraph-source">     Імена операцій, так само як і атрибутів, записуються з рядкової (малою) букви, а їх типи - із заголовної (великий) букви. При цьому обов'язковою частиною рядка запису операції є наявність імені операції і круглих дужок.</p><p align="justify" class="paragraph-source">     В якості прикладів запису операцій можна привести наступні позначення окремих операцій :</p><p align="justify" class="paragraph-source">     - +створити();</p><p align="justify" class="paragraph-source">     - +намалювати(форма: Багатокутник = прямокутник, колір_заливки : Color =  (0, 0, 255));</p><p align="justify" class="paragraph-source">     - запросити_рахунок_клієнта(номер_рахунку : Integer) : Currency;</p><ul class="list-source"><li align="justify">     видати_повідомлення() : {"Помилка ділення на нуль"}.</li></ul><p align="justify" class="paragraph-source">     Окрім внутрішнього устрою або структури класів на відповідній діаграмі вказуються різні стосунки між класами<i>.</i> При цьому сукупність типів таких стосунків фіксована в мові UML і зумовлена семантикою цих типів стосунків. Базовими стосунками або зв'язками в мові UML є:</p><p align="justify" class="paragraph-source">     - відношення залежності (dependency relationship);</p><p align="justify" class="paragraph-source">     - відношення асоціації (association relationship);</p><p align="justify" class="paragraph-source">     - відношення узагальнення (generalization relationship);</p><p align="justify" class="paragraph-source">     - відношення реалізації (realization relationship).</p><p align="justify" class="paragraph-source">     Кожен з цих стосунків має власне графічне представлення на діаграмі, яке відбиває взаємозв'язки між об'єктами відповідних класів. Проте для більшості фізичних систем, окрім найпростіших і тривіальніших, статичних представлень абсолютно недостатньо для моделювання процесів функціонування подібних систем, як в цілому, так і їх окремих підсистем і елементів.</p><p align="justify" class="paragraph-source">     Використовуючи пакет RequisitePro на панелі діаграм Ви можете відкрити декілька вікон з діаграмами. При запуску додатка повинне відкритися вікно діаграми класів, встановлене за умовчанням. Воно називається «Class Diagram : Logical View/Main». Ви можете вибрати це вікно або створити нове вікно діаграми класів. Для створення нового вікна виконайте наступні дії:</p><p align="justify" class="paragraph-source">     - натисніть правою кнопкою мишки на logical view і виберіть new&gt;class diagram (нова&gt;діаграма класів);</p><p align="justify" class="paragraph-source">     - дайте назву діаграмі, наприклад booking flight (бронювання рейсу);</p><p align="justify" class="paragraph-source">     - подвійним клацанням мишки на діаграмі (у вікні браузеру) відкрийте вікно на головній панелі.</p><p align="justify" class="paragraph-source">     Між панеллю браузеру і панеллю діаграм розташована вертикальна панель інструментів, як показано на рис. 4.2. Щоб помістити потрібний елемент на діаграму, Вам треба натиснути на іконку на цій панелі інструментів, а потім натиснути на потрібне місце на діаграмі, де Ви хочете помістити цей елемент.</p></div><span id="lnk6b47ad0ddaff4e40a195536f36a3bc9d"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg250_0_.jpg" height="254px" width="60px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 4.2 -  Панель інструментів для діаграми класів</p></div><span id="lnk4578c5ab9dc5412498f56623057ceee6"> </span><div class="section"><p align="justify" class="paragraph-source">     Створіть клас на діаграмі, виконуючи наступні дії:</p><p align="justify" class="paragraph-source">     - натисніть на іконку класу на панелі інструментів (п'ята іконка згори);</p><p align="justify" class="paragraph-source">     - натисніть на вікно class diagram (діаграма класів), щоб помістити на нього іконку;</p><p align="justify" class="paragraph-source">     - клас з'являється з назвою newclass;</p><p align="justify" class="paragraph-source">     - подвійним клацанням мишки на цьому класі відкрийте діалогове вікно class specification (характеристика класу), як показано на рис. 4.3;</p><p align="justify" class="paragraph-source">     - змініть назву класу, наприклад flightselector;</p><p align="justify" class="paragraph-source">     - введіть опис класу в області documentation (документація);</p><p align="justify" class="paragraph-source">     - виберіть закладку operation(операція);</p><p align="justify" class="paragraph-source">     - правою кнопкою мишки натисніть на головній панелі діалогового вікна і виберіть insert (вставити);</p><p align="justify" class="paragraph-source">     - назвіть операцію, наприклад getflights. коли ви натиснете enter, операція буде додана в список.</p></div><span id="lnk755f115e3f694cd0a4e826476615417c"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg253_0_.jpg" height="370px" width="258px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 4.3 - Діалогове вікно Class Specification </p></div><span id="lnk9de93e7522604ef595346e890cedc822"> </span><div class="section"><p align="justify" class="paragraph-source">     - подвійним клацанням мишки натисніть на назві операції;</p><p align="justify" class="paragraph-source">     - виберіть закладку detail (деталі), як показано на рис 4.4.</p></div><span id="lnkd9a83870c3ec4616ae3db352b5d56a12"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg262_0_.jpg" height="371px" width="253px" alt="" /> </p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source">Рисунок 4.4 - Додавання аргументів операції</p></div><span id="lnkc04f507762a04bd1a7f9aa62b58853b2"> </span><div class="section"><p align="justify" class="paragraph-source">     Діаграма станів описує процес зміни станів тільки одного класу, а точніше - одного екземпляра певного класу, т. е. моделює усі можливі зміни в стані конкретного об'єкту. При цьому зміна стану об'єкту може бути викликана зовнішніми діями з боку інших об'єктів або ззовні. Саме для опису реакції об'єкту на подібні зовнішні дії і використовуються діаграми станів.</p><p align="justify" class="paragraph-source">     Головне призначення цієї діаграми - описати можливі послідовності станів і переходів, які в сукупності характеризують поведінку елементу моделі впродовж його життєвого циклу. Діаграма станів представляє динамічну поведінку сутностей, на основі специфікації їх реакції на сприйняття деяких конкретних подій. Діаграма станів по суті є графом спеціального виду, який представляє деякий автомат.</p><p align="justify" class="paragraph-source">     Формалізм звичайного автомата заснований на виконанні наступних обов'язкових умов : </p><p align="justify" class="paragraph-source">     - автомат не запам'ятовує історію переміщення із стану в стан;</p><p align="justify" class="paragraph-source">     - у кожен момент часу автомат може знаходитися в одному і тільки в одному зі своїх станів;</p><p align="justify" class="paragraph-source">     - хоча процес зміни станів автомата відбувається в часі, явно концепція часу не входить у формалізм автомата;</p><p align="justify" class="paragraph-source">     - кількість станів автомата має бути обов'язкова кінцевим(у мові uml розглядаються тільки кінцеві автомати), і усі вони мають бути специфіковані явним чином;</p><p align="justify" class="paragraph-source">     - граф автомата не повинен містити ізольованих станів і переходів;</p><p align="justify" class="paragraph-source">     - автомат не повинен містити конфліктуючих переходів.</p><p align="justify" class="paragraph-source">     Таким чином, правила поведінки об'єкту, що моделюється деяким автоматом, визначаються, з одного боку, загальним формалізмом автомата, а з іншої - його графічним зображенням в мові UML у формі конкретної діаграми станів.</p></div><span id="lnkf6257ff1e3cd40e89e24b8adab95d7f6"> </span><div class="section"><p align="justify" class="paragraph-source">     Поняття стану(state) є фундаментальним не лише в метамоделі мови UML, але і в прикладному системному аналізі. Уся концепція динамічної системи ґрунтується на понятті стану системи. Стан може бути заданий у вигляді набору конкретних значень атрибутів класу або об'єкту, при цьому зміна їх окремих значень відбиватиме зміну стану модельованого класу або об'єкту.</p></div><span id="lnk91d46ce730f843fb82860343dfa33911"> </span><div class="section"><p align="left" class="paragraph-source"><img src="../res/files/jpg268_0_.jpg" height="207px" width="516px" alt="" /> </p></div><span id="lnk72628e7b153747a692cf370cb4c8f3df"> </span><div class="section"><p align="justify" class="paragraph-source">     Ім'я стану є рядком тексту, який розкриває змістовний сенс цього стану. Ім'я завжди записується із заголовної букви. Оскільки стан системи є складовою частиною процесу її функціонування, рекомендується в якості імені використати дієслова в теперішньому часі (дзвенить, друкує, чекає) або відповідне причастя(зайнятий, вільний, передано, отримано).</p><p align="justify" class="paragraph-source">     Простий перехід (simple transition) є відношенням між двома послідовними станами, яке вказує на факт зміни одного стану іншим. Перебування модельованого об'єкту в першому стані може супроводжуватися виконанням деяких дій, а перехід в другий стан буде можливий після завершення цих дій, а також після задоволення деяких додаткових умов. В цьому випадку говорять, що перехід спрацьовує, або відбувається спрацьовування переходу.</p><p align="justify" class="paragraph-source">     Спрацьовування переходу може залежати не лише від настання деякої події, але і від виконання певної умови, що називається сторожовою умовою. Об'єкт перейде з одного стану в інший у тому випадку, якщо сталася вказана подія і сторожова умова набуло значення "істина".</p><p align="justify" class="paragraph-source">     Термін подія (event) вимагає окремого пояснення, оскільки є самостійним елементом мови UML. Формально, подія є специфікацією деякого факту, що має місце в просторі і в часі. Після настання деякої події не можна вже повернутися до попередніх подій, якщо така можливість не передбачена явно в моделі.</p><p align="justify" class="paragraph-source">     Сторожова умова (guard condition), якщо воно є, завжди записується в прямих дужках після події і є деяким булевим вираженням. З контексту діаграми станів повинна явно виходити семантика цього виразу, а для запису вираження може використовуватися синтаксис мови об'єктних обмежень, основи якої викладені в додатку.</p><p align="justify" class="paragraph-source">     Введення для переходу сторожової умови дозволяє явно специфікувати семантику його спрацьовування. Якщо сторожова умова набуває значення "істина", то відповідний перехід може спрацювати, внаслідок чого об'єкт перейде в цільовий стан.</p><p align="justify" class="paragraph-source">     Складений стан (composite state) - такий складний стан, який складається з інших вкладених в нього станів. Останні виступатимуть по відношенню до першого як підстани (substate). Хоча між ними має місце відношення композиції, графічно усі вершини діаграми, які відповідають вкладеним станам, зображаються усередині символу складеного стану (рис.4.6). В цьому випадку розміри графічного символу складеного стану збільшуються, так щоб вмістити в себе усі підстани.Історичний стан (history state) застосовується в контексті складеного стану. Воно використовується для запам'ятовування того з послідовних підстанів, яке було поточним у момент виходу із складеного стану.</p></div><span id="lnk9c3db166b0684d34bdd9c614d0d98ecf"> </span><div class="section"><p align="left" class="paragraph-source"><img src="../res/files/jpg26a_0_.jpg" height="99px" width="528px" alt="" /> </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2010 ХНУРЕ, ПЗЕОМ, Шатовська Т. Б., <a href="mailto:shatovska@gmail.com">shatovska@gmail.com</a>;   ХНУРЕ, ПЗЕОМ, Репка В. Б., <a href="mailto:victoria_repka@kture.kharkov.ua">victoria_repka@kture.kharkov.ua</a><br /><a href="http://lersus.de/" title="Цей курс створено за допомогою авторської системи LERSUS" target="_blank">Розроблено за допомогою LERSUS</a></div></td></tr></table></td></tr></table></body></html>