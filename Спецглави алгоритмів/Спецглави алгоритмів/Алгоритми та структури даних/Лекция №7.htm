<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №8</h2>
<h2 align="center">Тема: Жадные алгоритмы.</h2>
<p>Многие оптимизационные задачи имеют более простые и быстрые алгоритмы, чем 
  те, которые дает метод динамического программирования. Такие алгоритмы получили 
  название жадных и делают на каждом шаге локально – оптимальный выбор в надежде, 
  что итоговое решение тоже окажется оптимальным. Это далеко не всегда так, но 
  для многих задач действительно получается оптимум. Для того чтобы узнать, даст 
  ли жадный алгоритм оптимум применительно к данной задаче, не существует общего 
  правила. Однако есть два цикла, которые необходимо проверить:</p>
<li></li> принцип жадного выбора;<br>
<li></li> свойство оптимальности для подзадач.<br></p>
<h3>Принцип жадного выбора.</h3>
<p>Он применим к задаче если последовательность локально оптимальных жадных выборов 
  приводит к глобальному оптимуму. На каждом шаге Ж. А. Берет “самый жирный кусок”, 
  а потом пытается сделать наилучший выбор среди оставшихся; алгоритм ДП принимает 
  решение, просчитав результаты всех возможных вариантов.</p>
<p>Как доказать что Ж.А. дает оптимальное решение? Сначала доказывают, что жадный 
  выбор на первом шаге не закрывает пути к оптимальному решению (для каждого решения 
  есть другое, согласованное с принципом Ж.Выб. и не хуже первого). Затем показывается 
  что подзадача, возникающая после жадного выбора на первом шаге аналогична исходной, 
  и рассуждение завершается по индукции.</p>
<h3>Оптимальность для подзадачи.</h3>
<p>Оптимальное решение задачи содержит в себе оптимальные решения задач.</p>
<h3>Дискретная задача о рюкзаке.</h3>
<p>Вор пробрался на склад, где хранится “n” вещей. Вещь номер “i” стоит U<sub>i</sub> долларов 
  и весит w<sub>i</sub> кг. (U<sub>i</sub> и w<sub>i</sub> – челые числа). Вор хочет украсть товара на максимальную 
  сумму, причем максимальный вес, который он может, унести w(целое). Что нужно 
  положить в рюкзак?</p>
<h3>Непрерывная задача о рюкзаке.</h3>
<p>Вор может дробить краденые товары на части и укладывать эти части в рюкзак, 
  а не обязательно целые части.</p>
<p>Обе задачи обладают свойством оптимальности для подзадач. Рассмотрим дискретную 
  задачу; пусть рюкзак загружен оптимально. Вынув из него вещь j получим решение 
  задачи о рюкзаке с максимальным весом W – w<sub>j</sub> b и набором из (n-1) веши. Аналогичное 
  рассуждение проходит и для непрерывной задачи: вынув из оптимально загруженного 
  рюкзака, в котором лежит w кг товара номер j, весь этот товар, получим оптимальное 
  решение непрерывной задачи, в которой максимальный вес равен W –w (вместо W), 
  а количество j-го товара равно w<sub>j</sub> – w (вместо w<sub>j</sub>).</p>
<p>Жадный выбор: вычислим цены в расчете на кг всех товаров (цена товара № i равна 
  U<sub>i</sub>/w<sub>i</sub>). Сначала вор берет самого дорогого товара по максимуму. 
  Если товар закончился, а рюкзак не заполнен, вор берет следующий по цене товар, 
  и т.д., пока не наберет вес W. т.к. товары надо отсортировать по ценам, на это 
  уйдет O(n log n) времени.</p>
<p>Жадный выбор для непрерывной задачи:</p>
<table width="400" border="1">
  <!--DWLayoutTable-->
  <tr> 
    <td>Товар 1 </td>
	<td>Товар 2</td>
	<td>Товар 3</td>
  </tr>
  <tr> 
    <td>Дорогой 1 </td>
	<td>Дорогой 2</td>
	<td>Дорогой 3</td>
  </tr>
  <tr>   
 <td></td>
 <TD WIDTH="67%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">Общий вес W</FONT></TD>
  </tr>
 
</table>
<p>Если убрать самый дорогой товар, то останется оптимально загруженный рюкзак 
  для товара 2 и товара 3.</p>
<p>Жадный выбор для дискретной задачи:</p>
<table width="400" border="1">
  <tr>
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">№ товара</FONT></TD> 
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">1</FONT></TD>  
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">2</FONT></TD> 
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">3</FONT></TD> 
  </tr>
  <tr>
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">Вес</FONT></TD> 
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">10 кг</FONT></TD>  
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">20 кг</FONT></TD> 
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">30 кг</FONT></TD> 
  </tr>
  <tr>
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">Стоимость</FONT></TD> 
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">60$</FONT></TD>  
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">100$</FONT></TD> 
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">120$</FONT></TD> 
  </tr>
  <tr>
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">Уз. цена</FONT></TD> 
   <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">6</FONT></TD>  
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">5</FONT></TD> 
    <TD WIDTH="25%" VALIGN="TOP" COLSPAN=3>
 <P ALIGN="CENTER">4</FONT></TD> 
  </tr>
</table>
<p>Если выбрать 1, то возможно 1+2=160$ или 1+3=180$ (рюкзак заполнен не полностью), 
  а оптимальный выбор 2+3=220$.</p>
<p>Следовательно, этот выбор не является жадным для дискретной задачи. </p>
<h3>Задача о выборе заявок.</h3>
<p>Пусть даны n – заявок на проведение занятий в одной и той же аудитории. Два 
  разных занятия не могут перекрываться по времени. В каждой заявке указаны начало 
  и конец занятия (S<sub>i</sub> и f<sub>i</sub> для i-й заявки). Разные заявки могут пересекаться, 
  и тогда можно удовлетворить только одну из них. Отождествим каждую заявку с 
  промежутком [S<sub>i</sub>, f<sub>i</sub>], так что конец одного занятия может совладать с началом 
  другого (это не пересечение).</p>
<p>Заявки с номерами i и j совместны, если интервалы [S<sub>i</sub>, f<sub>i</sub>] и [S<sub>j</sub>,
 f<sub>j</sub>] не пересекаются, 
  т.е f<sub>i</sub>&lt;=S<sub>j</sub> или f<sub>j</sub>&lt;=S<sub>i</sub>.</p>
<p>Задача о выборе заявок состоит в том, чтобы выбрать максимальное количество 
  совместных друг с другом заявок.</p>
<p>Жадный алгоритм работает следующим образом. Пусть заявки упорядочены в порядке 
  возрастания времени окончания:<br>
  f<sub>1</sub>&lt;=f<sub>2</sub>&lt;=…&lt;=f<sub>n</sub>.</p>
<p>Если это не так, их можно отсортировать за время O(n log n). Заявки с одинаковым 
  временем конца располагаем в произвольном порядке.</p>
<p>Жадность алгоритма будет состоять в том, что на каждом шаге упорядочивания 
  заявок, нужно очередную заявку выбирать так, чтобы время, оставшееся после выбора 
  очередной заявки было максимальным.</p>
<p>Пример. Задача о заявках(Рис.1).</p>
<p align="center"><img src="img/8vRis1.GIF" width="489" height="559"><br>
  Рис 1. Задача о заявках. </p>
<p>Пусть S и f – массивы, тогда</p>
<pre>Greedy_ Selector(s, f)<br>1.	n<img src="img/ctrelka_v_levo.GIF" width="22" height="14">length[S]<br>2.	A<img src="img/ctrelka_v_levo.GIF" width="22" height="14">{1}<br>3.	i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1<br>4.	for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">2 to n<br>5.	      do if Si=&gt;fi<br>6.	            then A<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A<img src="img/I.GIF" width="15" height="10">{i}<br>7.	            i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">i<br>8.	return A</pre>
<p>Доказательство правильности жадного алгоритма решения задачи о выборе заявок.</p>
<p>Заявки отсортированы по возрастанию времени окончания. Заявка с №1 кончается 
  раньше всех и ни с чем пересечься не может. Оставшееся время позволит поместить 
  максимальное число заявок, т.к. оно максимально, т.е. оптимальное множество 
  заявок следует искать среди заявок, содержащих заявку №1 т.е. существует оптимальное 
  решение, начинающееся с жадного выбора.</p>
<p>Все заявки, несовместные с №1 можно устранить. Задача сводится к выбору заявок 
  из оставшихся, т.е к предыдущей задаче с меньшим числом заявок.</p>
<p>Далее на каждом шаге жадный выбор, приходим к оптимальному решению.<br>
</p>
<h3>Коды Хаффмана.</h3>
<p>Файл из символов; известны частоты символов. Нужно построить двоичный код, 
  в котором каждый символ представляется в виде последовательности байтов, называют 
  кодовым словом.</p>
<p>Равномерный код: все кодовые слова одинаковую длину. </p>
<p>Неравномерный код: часто встречаются символы закодированные короткими последовательностями 
  битов, а редко встречаются – длинные.</p>
<p>Пример: имеется файл на 100000 символов, известны их частоты и известно, что 
  в файле всего 6 символов (a, b, c, d, e, f).</p>
<table width="400" border="1">
  <tr>
    <td>&nbsp;</td>
    <td>a</td>
    <td>b</td>
    <td>c</td>
    <td>d</td>
    <td>e</td>
    <td>f</td>
  </tr>
  <tr>
    <td>Количество (в тысячах) </td>
    <td>45</td>
    <td>13</td>
    <td>12</td>
    <td>16</td>
    <td>9</td>
    <td>5</td>
  </tr>
  <tr>
    <td>Равномерный код</td>
    <td>000</td>
    <td>001</td>
    <td>010</td>
    <td>011</td>
    <td>100</td>
    <td>101</td>
  </tr>
  <tr>
    <td>Неравномерный код</td>
    <td>0</td>
    <td>101</td>
    <td>100</td>
    <td>111</td>
    <td>1101</td>
    <td>1100</td>
  </tr>
</table>
<p><br>
  Равномерный код: (45*3+13*3+12*3+16*3+9*3+5*3)*1000=300000</p>
<p>Неравномерный код: (45+13*3+12*3+16*3+9*4+5*4)*1000=224000</p>
<h3>Префиксные коды. </h3>
<p>Рассматриваем только коды, в которых из двух последовательностей битов, представляющих 
  различные символы, ни одна не является префиксом другой. Такие коды называются 
  префиксными кодами.</p>
<p>При кодировании каждый символ заменяется на свой код. Для неравномерного кода, 
  например, abc записывается как 0101100. Для предикатного кода декодирование 
  однозначно и выполняется слева на право. Например, для неравномерного кода строка 
  001011101 разбивается на части 0.0.101.1101 и декодируется как aabe.</p>
<p>Для реализации декодирования надо хранить информацию о коде в удобной форме. 
  Одна из возможностей – представить код в виде двоичного дерева, листья которого 
  соответствуют кодируемым символам. При этом путь от вершины дерева до кодируемого 
  символа определяют кодирующую последовательность битов: левый поворот дает 0, 
  правый – 1.</p>
<p align="center"><img src="img/8vRis2.GIF" width="354" height="282"><br>
  а) равномерный код. </p>
<p align="center"><img src="img/8vRis3.GIF" width="364" height="311"> </p>
<p align="center">б) Неравномерный код.</p>
<p>Оптимальному для данного файла коду (дающему наибольшую степень сжатия) всегда 
  соответствует двоичное дерево, в котором всякая вершина не является листом, 
  имеет двоих действия.</p>
<p>Такое свойство оптимального кода позволяет доказать, что дерево оптимального 
  префиксного кода для файла в котором используются все символы из некоторого 
  множества С и только они, содержат ровно |C| листов, по одному на каждый символ 
  и равно |C|-1 узлов, не являющихся листьями.</p>
<p>Зная дерево Т, соответствующее префиксному коду, можно найти количество битов, 
  необходимое для кодирования файлов. Пусть f(c) обозначает число вхождений символа 
  с из алфавита С, а d<sub>t</sub>(c) – глубину соответствующего листа в дереве или, что 
  тоже самое, длину последовательности битов, кодирующей с. Тогда для кодирования 
  файла потребуется </p>
B(T)=<img src="img/Sum.GIF" width="15" height="17">f(c)d<sub>t</sub>(c) где с<img src="img/Prehadlegit.GIF" width="11" height="11">С 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7.1)<br>
<p>Это число называют стоимостью дерева Т.</p>
<h3>Построение кода Хаффмана.</h3>
<p>Хаффмен построил жадный алгоритм, который строит оптимальный префиксный код, 
  называемый кодом Хаффмена. Алгоритм строит дерево Т, соответствующее оптимальному 
  коду, снизу вверх, начиная с множеств |c| и делая |C|-1 слияний. Предполагается 
  что каждого символа “c” принадлежащего “C” задана его частота f(c). Для нахождения 
  двух объектов, подлежащих слиянию, используется очередь с приоритетами Ө, использующая 
  частоты f в качестве рангов – сливаются два объекта с наименьшими частотами. 
  В результате слияния получается новый объект (внутренняя вершина), частота которого 
  считается равной сумме частот двух сливаемых объектов.</p>
<pre>Huffman(C)<br>1.	n<img src="img/ctrelka_v_levo.GIF" width="22" height="14">|C|<br>2.	Ө<img src="img/ctrelka_v_levo.GIF" width="22" height="14">C<br>3.	for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1 to n-1<br>4.	     do Z<img src="img/ctrelka_v_levo.GIF" width="22" height="14">ALLOCATE-NODE()<br>5.	           x<img src="img/ctrelka_v_levo.GIF" width="22" height="14">left[Z]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">EXTRAKT-MIN(Ө)<br>6.	           y<img src="img/ctrelka_v_levo.GIF" width="22" height="14">right[Z]<img src="img/ctrelka_v_levo.GIF" width="22" height="14"> EXTRAKT-MIN(Ө)<br>7.	           f[Z]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">f[x]+f[y]<br>8.	           INSERT(Ө,Z)<br>9.	return  EXTRAKT-MIN(Ө)<br></pre>
<p>Строка 2: в очередь Ө помещаются символы из С с соответствующими частотами.</p>
<p>Строки 3-8: цикл, в котором n-1 раз повторяется следующая операция:</p>
<p>Из очереди извлекаются две вершины x и y с наименьшими частотами f[x] и f[y], 
  которые заменяются на одну вершину Z с частотой f[x]+f[y] и детьми x и y. В 
  конце в очереди остается один узел – корень построенного двоичного дерева, ссылка 
  на него возвращается в строке 9.</p>
<p>Продемонстрируем на вышеприведенном примере работу нашего алгоритма</p>
<p align="center"><img src="img/8vRis4.GIF" width="320" height="75"></p>
<p align="center"><img src="img/8vRis5.GIF" width="322" height="142"></p>
<p align="center"><img src="img/8vRis6.GIF" width="379" height="137"></p>
<p align="center"><img src="img/8vRis7.GIF" width="422" height="210"></p>
<p align="center"><img src="img/8vRis8.GIF" width="547" height="367"><br>
</p>
<p>Оценим время работы алгоритма, считая, что очередь Өреализована в виде двоичной 
  кучи. Инициализацию Ө в строке 2 можно провести за O(n) операций с помощью процедуры 
  Build_HEAP (для двоичных куч). Цикл в строках 3-8 исполняется (n-1) раз; поскольку 
  каждая операция с кучей требует времени O(log n), общее время будет O(n log 
  n), где n – количество символов в С.</p>
<h3>Принцип жадного выбора. </h3>
<p>Доказывается лема, показывающая, что построение оптимального дерева можно начать 
  со слияния двух символов с наименьшей частотой. </p>
<p>Стоимость слияния есть сумма частот сливаемых узлов. Доказывается, что стоимость 
  дерева равна сумме стоимостей всех слияний необходимых для его построения. Алгоритм 
  HOFFMAN на каждом шаге выбирает слияние, наименее увеличивающее стоимость (жадный 
  выбор).<br>
</p>
<h3>Свойство оптимальности для подзадач.</h3>
<p>Пусть фиксирован алгоритм С и два символа x и y этого алгоритма, а С’ – алфавит, 
  который получится из С, если выкинуть x и y и добавить новый символ z.</p>
<p>Рассмотрим кодовые деревья для С, в которых x и y (точнее, соответствующие 
  им листья) являются братьями. Каждому такому дереву соответствует кодовое дерево 
  для C`, которое получится, если выбросить вершины x и y, а их общего родителя 
  считать кодом символа z. </p>
<p>При этом соответствии каждому кодовому дереву для C` соответствует ровно два 
  кодовых дерева для С (в одном из них x – левый ребенок, в другом правый).</p>
<p>Пусть для каждого символа с из С фиксирована его частота f(c). Определим частоты 
  для символов из C`, считая частотой символа z сумму f(x)+f(y); для остальных 
  символов частоты остаются теми же, что и в с. Тогда для кодовых деревьев (обоих 
  алгоритмов) определены стоимости. Доказано, что стоимость соответствующих друг 
  другу деревьев Т и Т` отличаются на величину f(x)+f(y). Т.е. выполнено свойство 
  оптимальности для подзадач (оптимальное дерево Т соответствует оптимальному 
  дереву Т` для меньшей задачи).
</p>
<h3>Контрольные вопроси.</h3>
<ol>
  <li>В чем состоит принцип жадного выбора?</li>
  <li>Повторите самостоятельно доказательство оптимальности выбора заявок.</li>
  <li>Докажите самостоятельно правильность жадного выбора для кодов Хофмана.</li>
  <li>Приведите пример (свой) для демонстрации неверности выбора при решении дискретной 
    задачи о рюкзаке?<br>
  </li>
</ol>
<p>&nbsp;</p>
<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
