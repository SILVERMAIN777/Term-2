<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Итоговый контроль</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>

<h1 align="center">Итоговый контроль:</h1>
<P align=justify><br>
В качестве итогового контроля знаний рассматриваются решенные задачи из практических занятий и выполненные лабораторные работы.<P align=justify>
Для сдачи экзамена по курсу Вы должны предоставить преподавателю решенные задачи из двух практических занятий, и отчеты по трем лабораторным работам. Оценка будет определяться как среднее арифметическое этих пяти оценок.<P align=justify> 
Нерешенное задание участвует в среднем арифметическом экзаменационной оценки как «0» (например, если решено только второе задание на «5», и защищены две лабораторные работы на «5»и на «4», то итоговая экзаменационная оценка равна: (0+5+0+5+4)/5=14/5=3).<P><br>



<p>&nbsp;</p>
<h1 align="center">Вопросы к итоговому тесту:</h1>
<p>&nbsp;</p>
<ol>
  <li>Пусть массив S подает стек (пример): 
    <p><img src="img/31finaltest_Ris1.GIF" width="212" height="91"> </p>
    Последний элемент стека находится в четвертой ячейке стека. Покажите на рисунке, 
    работу операций PUSH(S,4), PUSH(S,1),PUSH(S,3), POP(S), PUSH(S,8), POP(S) 
    для стека реализованного с помощью массива S[1..6]. Сначала стек пустой. Возможное 
    переполнение стека (видается сообщение).</li>
  <li>Составьте алгоритм проверки переполнения стека и введите проверку в алгоритм 
    PUSH.</li>
  <li>Составьте алгоритм проверки пустоты и переполнение очереди. Введите соответствующие 
    проверки в алгоритмы ENQUEUE и DEQUEUE.</li>
  <li>Реализуйте на базе одного массива А[ 1..n] два стека суммарной длины не 
    больше n. Верхняя граница каждого стека ограничена числом n (один стек заполнен 
    полностью, второй - пустой).Стеки используют общую память.</li>
  <li>Стек разрешает прибавлять и удалять элементы только с одной стороны. В очереди 
    прибавлять элементы можно с одной стороны, а удалять с другой. Структура данных 
    дек (очередь с двумя концами) разрешает прибавлять и удалять элементы с обеих 
    концов. Составьте алгоритм реализации дека на базе массива.</li>
  <li>Составьте алгоритм реализации очереди на базе двух стеков. Оцените время 
    работы операций ENQUEUE и DEQUEUE при этой реализации. Сравните это время 
    и время для этих же операций, алгоритмы которых приведены выше.( Указание: 
    в первый стек ( S1) последовательность элементов записывается в прямом порядке, 
    во второй стек (S2) - в обратном; ENQUEUE реализуется как PUSH(S1,x), DEQUEUE 
    как POP(S2)).</li>
  <li>Покажите, что для списка из n элементов поиск в списке (LIST_SEARCH) имеет 
    в наиболее плохом случае сложность Ө(n); LIST_INSERT-О(1); LIST_DELETE-В 
    (1); LIST_DELETE с заданным ключом - Ө(n). </li>
  <li>Реализуйте стек на базе односторонне связного списка. Операции PUSH и POP 
    должны выполняться за время О(1).</li>
  <li>Напишите процедуру, которая сливает два односторонне связанных упорядоченных 
    списки в один (тоже упорядоченный).</li>
  <li>Напишите нерекурсивную процедуру, которая за время Ө (n) переставляет элементы 
    односторонне связанного списка в обратном направлении. Объем дополнительной 
    (кроме необходимой для хранения исходного списка) памяти должен быть О(1).</li>
  <li>Операция UNION (объединение) получает на входе две множеств, которые не 
    пересекаются, и возвращает их объединение. Реализуйте эту операцию так, чтобы 
    она работала за время О(1), подавая множества списками надлежащего типа.</li>
  <li>Напишите процедуру, которая сортирует список, ключами которого являются 
    целые числа, в направлении роста.</li>
  <li>Напишите рекурсивную процедуру, которая использует линейно возрастающее 
    время, и которая печатает ключи всех вершин бинарного дерева.</li>
  <li>Сделайте тоже самое, что и в 13, но без использования рекурсии (используйте 
    стек).</li>
  <li>Нарисуйте бинарные деревья поиска высоты 2,3,4,5,6 для множества ключей 
    {1,4,5,10,16,17,21}.</li>
  <li>Напишите нерекурсивный алгоритм, который печатает ключи в бинарном дереве 
    поиска. Ключи расположены в возрастающем порядке.</li>
  <li>Напишите итеративную (без рекурсии) версию процедуры Tree_search (x,k)/</li>
  <li>Напишите процедуру Tree_predecessor (x).</li>
  <li>Набор из n чисел можно отсортировать, сначала построив из них бинарное дерево 
    поиска (Tree_insert), а потом обойти дерево с помощью процедуры Inorder_ tree_walk. 
    Сделайте с двух вышеупомянутых процедур процедуру сортировки и определите 
    время ее работы в наилучшем и наиболее плохом случаях.</li>
  <li>Если в z двое детей, мы можем использовать в Tree_delete не следующий элемент, 
    а предыдущий. Измените для этого текст процедуры Tree_delete.</li>
  <li>Напишите процедуру BFS, если граф представлен в виде матрицы смежности.</li>
  <li>Пусть G=(V,E) - неориентированный граф. Придумайте алгоритм, который отыскивает 
    путь в графе, который проходит каждое ребро ровно по одному разу в каждую 
    сторону.</li>
  <li>Задан граф G=(V,E) с начальной вершиной S. Рассматривается подграф, вершинами 
    которого есть доступные с S вершины, а ребрами есть (?[V],V) для всех доступных 
    V, кроме S. Постройте алгоритм, который находит кратчайшие пути из S в V.</li>
  <li>Рассмотрите алгоритм Крускала в литературном источнике( что имеется). Продемонстрируйте 
    его работу на придуманном вами графе.</li>
  <li>Сделайте тоже именно, что и в 24, но с алгоритмом Прима.</li>
  <li>Проанализируйте работу алгоритма Белмана-Форда на придуманном вами графе 
    с поиском кратчайших путей из одной вершины. Алгоритм возьмите из литературного 
    источника.</li>
  <li>Сделайте тоже именно, что и в 26, но с алгоритмом Флойда-Уоршола по поиску 
    кратчайших путей для всех пар вершин.</li>
</ol>


<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>

</body>
</html>
