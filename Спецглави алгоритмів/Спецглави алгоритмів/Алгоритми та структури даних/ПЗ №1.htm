<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>

<h2 align="center">Практическое занятие №1</h2>
<h2 align="center">Тема:ДЕРЕВЬЯ</h2>
<p>Наиболее используемые бинарные деревья. Каждая вершина дерева - это запись 
  с несколькими полями. Одно из этих полей вмещает ключ, т.е. информацию, связанную 
  с вершиной, а другие - указатели. На рис.2 представлено дерево без поля, которое 
  в каждой вершине задает ключ, другие поля- указатели на сопредельные вершины. 
  Как показывает рис.2 представление бинарного дерева Т использует поля p, left, 
  right, где сохраняются указатели на отца, левого и правого ребенка вершины х 
  соответственно. Если p[x]=NIL, x- корень (root); если в х нет левого или правого 
  ребенка, то left[x] или right[x] есть NIL. С деревом Т связан атрибут root[T]-указатель 
  на его корень. При root[T]=NIL дерево- пустое. </p>
<p>Среди бинарных деревьев выделяются деревья поиска. Ключи в бинарном дереве 
  поиска сохраняются с соблюдением свойства упорядоченности (binary_search_tree_property):</p>
<p>пусть х- произвольная вершина дерева поиска; y находится в левом поддереве 
  вершины х; </p>
<p>тогда key[y]&lt;=key[x]; если y находится в правом поддереве х, то key[y]&gt;=key[x].<br>
  Пример дерева поиска приведен на рис.3. Обратите внимание, што в бинарном дереве 
  важно следить, какой ребенок (левый или правый) рассматриваемой вершины существует, 
  чтобы верно использовать указатели. На рис. 3 приведено только поле, которое 
  подает ключ вершине.</p>
<p>Свойство упорядочения разрешает напечатать все ключи в неуменьшительном порядке 
  с помощью простого рекурсивного алгоритма (Inorder_tree_walk). Этот алгоритм 
  печатает ключ корня поддерева после ключей его левого поддерева. Вызов Inorder_tree_walk(root[T]) 
  печатает все ключи, которые входят в дерево с корнем root[T].
</p>
<p><img src="img/21PZ_Ris1.GIF" width="639" height="267"></p>
<p align="center">Рис.1 Бинарное дерево</p>
<p align="center"><img src="img/21PZ_Ris2.GIF" width="589" height="264"></p>
<p align="center">Рис. 2. Дерево поиска.</p>
<pre>Inorder_tree_walk (x)</pre>
<p>1. if x /= NIL<br>
  2. then Inorder_tree_walk (left[x])<br>
  3. печатать rte[x]<br>
  4. Inorder_tree_walk (right[x])
</p>
<p> Для дерева на рис. 3 алгоритм напечатает 2,3,5,5,?,8. Время работы на деревья 
  с n вершинами есть Ө(n).</p>
<p>Рассмотрим теперь операции : поиска (Search), поиска минимального элемента(Minimum), 
  поиска максимального элемента(Maximum), предыдущего элемента(Predecessor), следующего 
  элемента(Successor) за время О(h), где h - вымсота дерева. Высотой дерева считается 
  максимальный путь (количество дуг) от корня до листьев.</p>
<p>Процедура поиска получает на вход искомый ключ к и указатель х на корень поддерева, 
  в котором идет поиск. Она возвращает указатель на вершину с ключом к, если такая 
  есть, или NIL при ее отсутствии.
</p>
<pre>Tree_search (x,k)</pre>
<p>1. if x=NIL or k=key[x]<br>
  2. then return x<br>
  3. if k&lt;key[x]<br>
  4. then return Tree_sirch (left[x],k)<br>
  5. else return Tree_search (right[x],k)<br>
</p>
<p>В процессе поиска мы движемся от корня, сравнивая ключи двух вершин. Если они 
  равные , поиск заканчивается. При их неравенстве поиск продлевается в левом 
  или правом поддереве. Длина пути поиска не превышает высоты дерева, поэтому 
  время оценивается как О(h).</p>
<p>Минимальный ключ в дереве поиска можно найти , проходя указателями left от 
  корня (пока не достигнем NIL). Процедура возвращает указатель на минимальный 
  элемент поддерева с корнем х.<br>
</p>
<pre>Tree_msnsmum (x)</pre>
<p>1. while left[x]/=NIL<br>
  2. do x<img src="img/ctrelka_v_levo.GIF" width="22" height="14">left[x]<br>
  3. return x </p>
<p>Аналогично определяется максимальный ключ дерева.</p>
<pre>Tre_maximum (x)</pre>
<p>1. while right[x]/=NIL<br>
  2. do x<img src="img/ctrelka_v_levo.GIF" width="22" height="14">right[x]<br>
  3. return x </p>
<p>Чтобы найти элемент (ключ) следующий за данным, надо выполнить процедуру, которая 
  возвращает указатель на следующий за х элемент. Этот элемент имеет ключ, следующий 
  за указанным.</p>
<pre>      Tree_successor (x)
1.	if right[x]/=NIL
2.	    then return Tree_minimum(right[x])
3.	y(p[x]<br>4.	while y/=NIL and x=right[y]
5.	          do x<img src="img/ctrelka_v_levo.GIF" width="22" height="14">y<br>6.	               y<img src="img/ctrelka_v_levo.GIF" width="22" height="14">p[x]
7.	return y </pre>
<p>Процедура Tree_insert прибавляет заданный элемент в соответствующее место дерева 
  поиска, сохраняя свойство упорядоченности, и может быть использованная для построения 
  дерева поиска из множества ключей. Параметром процедуры является указатель z 
  на новую вершину, куда помещено key[z] (значение добавленного ключа), left[z]=NIL, 
  right[z]=NIL. В ходе выполнения процедуры дерево Т изменяется.</p>
<pre>      Tree_insert (T,z)
1.	y(NIL
2.	x(root[T]
3.	while x/=NIL
4.	         do y<img src="img/ctrelka_v_levo.GIF" width="22" height="14">x
5.	              if key[z]&lt;key[x]
6.	                  then x<img src="img/ctrelka_v_levo.GIF" width="22" height="14">left[x]
7.	                  else  x<img src="img/ctrelka_v_levo.GIF" width="22" height="14"> right[x]
8.	p[z](y
9.	if y=NIL
10.	    then root[T]   <img src="img/ctrelka_v_levo.GIF" width="22" height="14">z
11.	    else if key[z]&lt;key[y]
12.	               then left[y]   <img src="img/ctrelka_v_levo.GIF" width="22" height="14">z
13.	               else  right[y]   <img src="img/ctrelka_v_levo.GIF" width="22" height="14">z<br></pre>
<p>Параметром процедуры изъятия элемента из дерева поиска есть указатель на исключаемую 
  вершину. При изъятии возможные три случая. Если в z нет детей, для изъятия z 
  достаточно поместить NIL в соответствующее поле его отца (вместо z). Если у 
  z є один ребенок, можно „вирезать” z, соединивши его отца напрямую с этим ребенком. 
  Если детей двое, нужны некоторые приготавливания: находится следующий (в смысле 
  порядка на ключах) за z елемент в; он не имеет левого ребенка. Теперь можно 
  скопировать ключ и дополнительные данные из вершины y в вершину z, а самую вершину 
  y изъять описанным выше средством. Процедура Tree-delete (T,z) изымает элемент 
  z из дерева Т.</p>
<pre>      Tree_Delete (T, z)
1 if left [z] = NIL or right [z] = NIL
2 	then y <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> z
3 	else y <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> Tree_Successor (z)
4 if left [y] <img src="img/NeRavno.GIF" width="10" height="10"> NIL
5 	then x <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> left [y]
6 	else x <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> right [y]
7 if x <img src="img/NeRavno.GIF" width="10" height="10"> NIL
8 	then p [x] <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> p [y]
9 if p [y] = NIL
10 	then root [T]    <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> x
11 	else if y = left [p[y]]
12 		then left [p[y]]    <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> x
13 		else right [p[y]]    <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> x
14 if y <img src="img/NeRavno.GIF" width="10" height="10"> z
15 	then key [z]    <img src="img/ctrelka_v_levo.GIF" width="22" height="14"> key [y]
16 	        копирование дополнительных данных, связанных с y
17 return y</pre>
<h3>Упражнения</h3>
<ol>
  <li>Напишите рекурсивную процедуру, которая использует линейно возрастающее 
    время, и которая печатает ключи всех вершин бинарного дерева.</li>
  <li>Сделайте тоже самое, что и в 1.3.1, но без использования рекурсии (используйте 
    стек).</li>
  <li>Нарисуйте бинарные деревья поиска высоты 2,3,4,5,6 для множества ключей 
    <br>
    {1,4,5,10,16,17,21}.</li>
  <li>Напишите нерекурсивный алгоритм, который печатает ключи в бинарном дереве 
    поиска. Ключи расположены в возрастающем порядке.</li>
  <li>Напишите итеративную (без рекурсии) версию процедуры Tree_search (x,k)/</li>
  <li>Напишите процедуру Tree_predecessor (x).</li>
  <li>Набор из n чисел можно отсортировать, сначала построив из них бинарное дерево 
    поиска (Tree_insert), а потом обойти дерево с помощью процедуры Inorder_ tree_walk. 
    Сделайте с двух вышеупомянутых процедур процедуру сортировки и определите 
    время ее работы в наилучшем и наиболее плохом случаях.</li>
  <li>Если в z двое детей, мы можем использовать в Tree_delete не следующий элемент, 
    а предыдущий. Измените для этого текст процедуры Tree_delete.<br>
  </li>
</ol>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="ПЗ №2.htm">Практическое занятие №2.</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
