<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №5. </h2>
<h2 align="center">Тема: Рекурсивные алгоритмы. Метод составления алгоритмов “разделяй 
  и властвуй”.</h2>
<p>Рекурсия – фундаментальное математическое понятие. Она предполагает пошаговую 
  организацию вычислительного процесса, где вычисления производятся по одному 
  и тому же алгоритму, но каждый раз с меньшим объемом данных. Предыдущий этап 
  не может завершиться, т.к. его результат вычисляется через результат этого же 
  алгоритма, но с меньшим объемом данных. Такая организация вычислительного процесса 
  предполагает получение результата на последнем шаге. Затем производится возврат 
  к недовычисленным шагам до получения окончательного результата. Рассмотрим пример 
  рекурсии для нахождения суммы двух натуральных чисел z=x+y. Запишем эту функцию 
  в термальном виде z=f+(x,y). Значение функции для y: x+(y+1)=(x+y)+1=z+1, или 
  f(x,y+1)=f+(x,y)+1. Если считать , что z+1 – функция, которая вычисляет значение 
  следующего натурального числа через предыдущее, то имеем рекурсивное определение 
  для функции сложения. Если y=0, то f+(x,0)=x. Таким образом имеем рекурсивное 
  определение для функции сложения:</p>
<p><img src="img/5vRis1.GIF" width="261" height="52"><br>
  Базис рекурсии – это тот последний шаг рекурсии, где получается результат шага. 
  Продемонстрируем функционирование рекурсивной схемы на примере вычисления f+(4, 
  3).</p>
<p>В соответствии со второй строкой рекурсивного определения имеем:<br>
  f+(4,3)=f+(4,2+1)=f+(4,2)+1 выход для вычисления f+(4,2), <br>
  f+(4,2)=f+(4,1+1)=f+(4,1)+1 выход для вычисления f+(4,1),<br>
  f+(4,1)=f+(4,0+1)=f+(4,0)+1=4+1=5.</p>
<p>Теперь производится возврат к недовычисленным двум шагам: <br>
  f+(4,1)+1=5+1=6,<br>
  f+(4,2)+1=6+1=7.</p>
<p>Следовательно f+(4,3)=7.</p>
<p>В рекурсивных алгоритмах предполагается механизм выхода из предыдущего шага 
  с сохранением состояний оставленного алгоритма и механизм возврата для осуществления 
  “довычислений”. При составлении рекурсивного алгоритма эти соображения остаются 
  “за кадром” для составляющего алгоритм, но о них нужно помнить. Кроме того, 
  при использовании рекурсии нужно всегда помнить о базисе рекурсии, который задает 
  результат для последнего шага рекурсивного вычисления.</p>
<p>Рассмотрим пример составления рекурсивного алгоритма для вычисления функции 
  n!. Сначала составим алгоритм пошаговым методом (без рекурсии):</p>
<p>FACT_it(n).<br>
  1. F<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1<br>
  2. for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1 to n<br>
  3. do F<img src="img/ctrelka_v_levo.GIF" width="22" height="14">F*i<br>
  4. return F<br>
  <br>
  Здесь используется формула для вычисления n!=1*2*3*…*n. Оценим временную сложность 
  T(n) этого алгоритма. Для строк 1,4 время оценивается как константа Ө(1). Для 
  строк 2, 3 время оценивается как Ө (n).<br>
  T(n= Ө (n)+ Ө (1)= Ө (n).</p>
<p>Составим теперь рекурсивный алгоритм вычисления функции n!, учитывая, что n!=(n-1)!*n. 
  Базис рекурсии имеем при n=0, т. е. O!=1. В рекурсивных алгоритмах проверка 
  базиса является одной из первых команд (строк).<br>
  <br>
  FACT_rek(n) оценка<br>
  1. if n=0 Ө (1) <br>
  2. then return 1 Ө (1)<br>
  3. return FACT_rek(n-1)*n T(n-1)</p>
<p>Методика оценки рекурсивных алгоритмов аналогична оценке пошаговых алгоритмов, 
  но если строка содержит рекурсивное обращение, то она оценивается той же функцией. 
  Так в алгоритме FACT_rek, если FACT_rek(n) оценивается как T(n), то FACT_rek(n-1) 
  оценивается как T(n-1). Общая оценка алгоритма FACT_rek, получается как сумма 
  оценок его строк:<br>
  T(n)= Ө (1)+ Ө (1)+T(n-1)=T(n-1)+1.</p>
<p>Равенство T(n)= T(n-1)+1 называется рекурсивным соотношением, где роль неизвестного 
  играет функция T(n). Решая рекурсивное соотношение можно получить вид функции 
  T(n).</p>
<p>Решить T(n)= T(n-1)+1 можно методом итераций:<br>
  T(n-1)= T(n-2)+1<br>
  T(n-2)= T(n-3)+1 <br>
  …<br>
  T(2)= T(1)+1.<br>
  <br>
  Учитывая, что T(1)= Ө (1)=1 и подставляя итерации в основную формулу получим: 
  T(n)=T(1)+1+…+1=n= Ө (n), так как количество единиц справа (пока дойдем в итерациях 
  до T(1), и учитывая T(1)=1) есть n.</p>
<p>Сравнивая пошаговый алгоритм с рекурсивным, отмечаем их одинаковую сложность 
  Ө (n). НО, учитывая, рекурсивный алгоритм требует для реализации дополнительные 
  ресурсы на осуществление рекурсии, следует отдать предпочтение пошаговому алгоритму.</p>
<p>Рассмотрим теперь рекурсивный алгоритм для сортировки чисел. Для составления 
  рекурсивного алгоритма мы используем метод “разделяй и властвуй”, который предписывает, 
  решая некоторую задачу, разбить ее на подзадачи и каждую подзадачу решить тем 
  же алгоритмом, что и основную задачу. Для сортировки исходный массив разбивается 
  на две части меньшего размера (например, на пополам). Затем обе половинки сортируются 
  отдельно. После сортировки половинок их следует соединить (слить) вместе, производя 
  сортировку при слиянии. Рекурсивное разбиение задачи на меньшее происходит до 
  тех пор, пока размер массива не дойдет до единицы (любой массив длинны 1 упорядочен).</p>
<p>Будем считать, что соединение двух упорядоченных массивов в один производится 
  с помощью алгоритма Slianie(A,p,q,r). Параметрами этого алгоритма являются имя 
  массива A, и числа p, q, r, указывающее границы сливаемых участков (смежных 
  в массиве А). Алгоритм предполагает, что p&lt;=q&lt;r и что участки A[p..q] 
  и A[q+1,r] уже отсортированы, и сливай ихв один A[p..r] .</p>
<p>Сортировка слиянием для массива A=&lt;5, 2, 4, 6, 1, 3, 2, 6&gt;(Рис.1).</p>
<p align="center"><img src="img/5vRis2.GIF" width="642" height="270"><br>
  Рис.1.Сортировка слиянием для массива A=&lt;5, 2, 4, 6, 1, 3, 2, 6&gt;. </p>
<p>Ниже приводится алгоритм сортировки слиянием Sort_Slijan(A, p, r), которая 
  сортирует участок A[p..r] массива А, не меняя остальную часть массива. При p=r 
  участок содержит максимум один элемент, и тем самым уже отсортирован. В противном 
  случае мы отыщем число q, которое делит участок на две примерно равные части 
  A[p..q] и A[q+1..r], каждая из которых содержит</p>
<p><img src="img/LVC.GIF" width="8" height="20">n/2<img src="img/PVC.GIF" width="9" height="20"> 
  и <img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20"> 
  элементов. Здесь через <img src="img/LNC.GIF" width="10" height="20">x<img src="img/PNC.GIF" width="10" height="20"> 
  обозначена целая часть с недостатком, а через <img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">-с 
  избытком.</p>
<p>
<pre>Sort_Slijan(A, p, r)
                                               Оценка
1.	if p&lt;r                                      Ө (1)
2.	      then q<img src="img/ctrelka_v_levo.GIF"><img src="img/LNC.GIF" width="10" height="20">(p+r)/2<img src="img/PNC.GIF" width="10" height="20">                   Ө (1)
3.	             Sort_Slijan(A, p, q)           T(n/2)
4.	             Sort_Slijan(A, q+1, r)         T(n/2) 
5.	             Sort_Slijan(A, p, q, r)        f(n)</pre>
<p>Весь массив А теперь можно отсортировать с помощью вызова Sort_Slijan(A, 1, 
  length[A]), где n= length[A] – размер массива. Если и есть степень двойка, т. 
  е. n=2<sup>k</sup>, то в процессе сортировки произойдет слияние пар элементов в отсортированные 
  участки длины 2, 4, 8и т. д (на последнем шаге сливаются два отсортированных 
  участка длинны n/2).</p>
<p>Для оценки алгоритма Sort_Slijan сначала положим, что n=2<sup>k</sup>. В записи 
  алгоритма Sort_Slijan записаны оценки каждой строки. Функция T(n) выразится 
  как:<br>
  T(n)= Ө (1)+ Ө (1)+2T(n/2)+f(n)<br>
  или, учитывая поглощение Ө (1) функцией f(n),<br>
  T(n)=2T(n/2)+f(n). (4.1)</p>
<p>Для решения рекуррентного соотношения (4.1) необходимо определить функцию f(n), 
  для чего нужно составить алгоритм Slijanie. Пусть при соединении двух отсортированных 
  массивов мы используем следующие действия: сравниваем текущие (левые) элементы 
  массивов, меньший элемент записываем в промежуточный массив, и сдвигаемся вправо 
  на один элемент с массиве с меньшим элементом, эту процедуру производим до исчерпания 
  одного из массивов, оставшиеся элементы переносим в промежуточный массив, а 
  из него все элементы – в массив А.</p>
<p>Пример выполнения процедуры слияния:</p>
<p><img src="img/5vRis3.GIF" width="444" height="177"><br>
  Здесь сливаются два массива 2 4 5 6 и 1 2 3 6.</p>
<p>Ниже приводится алгоритм слияния.</p>
<pre>Slijanie(A, p, q, r).
1.	k<img src="img/ctrelka_v_levo.GIF" width="22" height="14">p
2.	l<img src="img/ctrelka_v_levo.GIF" width="22" height="14">q+1
3.	m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1
4.	While k<=q and l<=r
5.	      do if A[k]>A[l]
6.	                 then RAB[m]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[l]
7.	                         l<img src="img/ctrelka_v_levo.GIF" width="22" height="14">l+1
8.	                  else RAB[m]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[k]
9.	           k<img src="img/ctrelka_v_levo.GIF" width="22" height="14">k+1
10.	           m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m+1
11.	 if k>q
12.	     then for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">l to r
13.	                 do RAB[m]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[i]
14.	                        m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m+1
15.	     else for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">k to q
16.	                 do RAB[m]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[i]
17.	                       m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m+1
18.	 m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m+1
19.	 for j<img src="img/ctrelka_v_levo.GIF" width="22" height="14">r downto p
20.	                 do A[j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">RAB[m]
21.	                        m<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m-1   
</pre>
<p>В 19 строке использованы циклы for с downto, что задает шаг цикла –1, и цикл 
  работает с уменьшающейся управляющей переменной от r до p. Оценим временную 
  сложность f(n) этого алгоритма. Строки 1-3: Ө(1); строки 4-10 повторяются не 
  более, чем n раз, потому их оценка Ө(n); строка 11: Ө(1); строки 12-17 повторяются 
  не более, чем n раз, поэтому их цена Ө(n); строка (18) – Ө (1); строки 19-21 
  – Ө(n).</p>
<p>f(n)=3 Ө (1)+3Ө(n)= Ө (n)=n</p>
<p>С учетом этой формулы (4.1) превращается в</p>
<p>T(n)=2T(n/2)+n (4.2)</p>
<p>Решим (4.2). Для этого сделаем замену n на 2<sup>k</sup>.</p>
<p>(n=2<sup>k</sup>): T(2<sup>k</sup>)=2T(2<sup>k-1</sup>)+2<sup>k</sup>. </p>
<p>Разделив обе части этого неравенства на 2<sup>k</sup> получим</p>
<p> T(2<sup>k</sup>)/2<sup>k</sup>=2T(2<sup>k-1</sup>)/2<sup>k-1</sup>+1. (4.3)</p>
<p>Из (4.3) находим итерации:</p>
<p>T(2<sup>k-1</sup>)/2<sup>k-1</sup>=2T(2<sup>k-2</sup>)/2<sup>k-2</sup>+1.<br>
  T(2<sup>k-2</sup>)/2<sup>k-2</sup>=2T(2<sup>k-3</sup>)/2<sup>k-3</sup>+1.<br>
  …<br>
  T(2)/2=T(1)+1</p>
<p>Учитывая, что T(1)=1, и подставляя итерации в (4.3) имеем:</p>
<p>T(2<sup>k</sup>)/2<sup>k</sup>=1+…+1 (4.1)</p>
<p>Так как в правой части имеется log n единиц (n=2<sup>k</sup>, k=log n) (4.4) перепишется 
  как </p>
<p>T(2<sup>k</sup>)/2<sup>k</sup>=log n (4.5)</p>
<p>Заменяя 2<sup>k</sup> на n проведя преобразование получим </p>
<p>T(n)=n log n.<br>
  <br>
  Можно показать, что в этом случае T(n)= Ө (n log n). </p>
<p>Сравним теперь сортировки вставками и слиянием. Поскольку алгоритм слияния 
  рекурсивный и требует время на выполнение рекурсии, которое никак не учтено 
  в самом алгоритме, ухудшим характеристики Sort_Slijan с помощью коэффициентов 
  и выбора ЭВМ реализации. </p>
<p>Итак алгоритм Sort_Vstk имеет характеристику T(n)= Ө (n<sup>2</sup>), а Sort_Slijan 
  – T(n)= Ө (n log n).<br>
  <br>
  Для Sort_Vstk будем считать степень роста времени 2n<sup>2</sup>, а Sort_Slijan – 50 n 
  log n (в 50 раз хуже). Пусть Sort_Slijan выполняется на ЭВМ с 10<sup>8</sup>операций/сек, 
  а Sort_Vstk 106операций/сек (в 100 раз хуже). </p>
<p>Время для Sort_Vstk: общее количество операций для сортировки 10<sup>6</sup> чисел 2*(10<sup>6</sup>)<sup>2</sup>, 
  быстродействие 10<sup>8</sup>опер/сек, время (2*10<sup>12</sup>)/10<sup>8</sup>=20000 сек =5,56 час.</p>
<p>Время для Sort_Slijan при сортировке тех же 10<sup>6</sup> чисел: </p>
<p>50*10<sup>6</sup> log 10<sup>6</sup>/10<sup>6</sup>оп/сек=50*6 log 10=300*3.3 
  сек=990 сек = 17 мин.</p>
<p>Результат поразительный: один алгоритм работает на миллионе чисел 5.56 час, 
  а другой – всего 17 мин.</p>
<h3>Контрольные вопросы.<br>
</h3>
<ol>
  <li>Зачем нужен базис рекурсии?</li>
  <li>Какой алгоритм называется рекурсивным?</li>
  <li>Что такое рекуррентное соотношение?</li>
  <li>Назовите методы решения рекуррентных соотношений.</li>
  <li>Какой алгоритм лучше, тот который характеризуется функцией n*log n или 5*(n-1)*log 
    n?</li>
</ol>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Лаб №2.htm">Лабораторная работа №2. Составление алгоритмов на бинарных деревьях.</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
