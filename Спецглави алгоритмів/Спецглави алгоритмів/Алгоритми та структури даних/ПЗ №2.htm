<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Практическое занятие №2</h2>
<h2 align="center">Тема: ГРАФЫ. </h2>
<p>&nbsp;</p>
<p>В этом разделе рассмотрены способы представления графов и некоторые алгоритмы 
  на графах. Существует два стандартных способа подать граф G=(V,E) – как набор 
  списков сопредельных вершин, или как матрицу смежности. Первый способ желательный 
  для разреженных графов – тех в которых |E| намного меньше |V|2. Для компактных 
  графов (|E|?|V|?) желательным есть представления с помощью матриц смежности. 
  Матрица смежности разрешает быстро определить, соединены ли две вершины ребром.</p>
<p>Представление графа G=(V,E) в виде списков сопредельных вершин использует массив 
  Adj из |V| списков - по одном на вершину. Для каждой вершины U есть V список 
  сопредельных вершин Adj[U] содержит в произвольном порядке (указчики) на все 
  сопредельные с ней вершины <br>
  ( все вершины V для которых (U,V) есть Е). На рис. 4 показано представление 
  графа в виде диаграммы(а), списков сопредельных вершин б), матрицы смежности 
  в).<br>
</p>
<p align="center"><img src="img/22PZ_Ris1.GIF" width="517" height="404"></p>
<p align="center">Рис.4 Представление неориентированного графа.</p>
<p>Для ориентированного графа сумма длин всех списков сопредельных вершин равняется 
  общему количеству ребер: ребру (U,V) отвечает элемент списка Adj[U]. Для неориентированного 
  графа эта сумма равняется двойному количеству ребер. В обеих случаях количество 
  памяти оценивается функцией O(max(V,E))=O(V+E).</p>
<h3>Поиск в ширину.</h3>
<p>Обработка информации, связанной с вершинами графа, нуждается в алгоритмах обхода 
  графа, которые гарантируют пребывания в каждой вершине графа. Такие алгоритмы 
  называют алгоритмами поиска на графах. Одним из алгоритмов поиска называют поиск 
  в ширину.</p>
<p>Пусть задан граф G=(V,E) и зафиксированная начальная вершина S. Расстоянием 
  между двумя вершинами называется длина (количество ребер) кратчайшего пути. 
  Алгоритм поиска в ширину пересчитывает все доступные с S (если идти ребрами) 
  вершины в порядке отставные от S. В процессе поиска из графа выделяется часть, 
  которая называется “деревом поиска в ширину” с корнем S. Она вмещает все доступные 
  с S вершины (и только их). Для каждой из них путь из корня в дереве поиска будет 
  одним из менее коротких путей (из начальной вершины) в графе.</p>
<p>Для наглядности будем считать, что с каждой вершиной графа связана информация: 
  вершины может быть белой, серой или черной. С начала они все белые, но в ходе 
  работы алгоритма изменяют цвет. Серые и черные вершины - это те, что алгоритм 
  уже проявил. <br>
  Поддерживается такое свойство: если (U,V) есть Е і U - черная, то V - серая 
  или черная вершина. Т.е., только серые вершины могут иметь сопредельные еще 
  невыявленные вершины.
</p>
<p>Сначала дерево поиска составляется только из корня - начальной вершины S. Как 
  только алгоритм обнаруживает белую вершину V, сопредельную с раньше найденной 
  вершиной U, вершина V (вместе с ребром (U,V)) прибавляется к дереву поиска. 
  V - ребенок вершины U, а U - отец V. Каждая вершина оказывается только один 
  раз, так что двух родителей у нее быть не может. Двигаясь от вершины до корня, 
  мы проходим всех ее родителей( предков).</p>
<p>Приведенная ниже процедура BFS (bread-first search - поиск в ширину) использует 
  представление графа G=(V,E) списками сопредельных вершин. Для каждой вершины 
  U графа дополнительно сохраняется ее цвет color[U] и ее предшественник ?[U]. 
  Если предшественника нет( например, когда U=S, или еще не выявленная), ?[U]=NIL. 
  Кроме того, расстояние от S до U записывается в поле d[U]. Процедура использует 
  также очередь Q для хранения множества серых вершин.</p>
<pre>BFS(G,S)
1	for каждой вершины U є (V[G] - {S})
2	     do color[U]&lt;белый
3	          d[U] &lt; ?
4	          ?[U] = NIL
5	color[S] &lt; серый
6	d[S] &lt; 0
7	?[S] = NIL
8	Q &lt; {S}
9	While Q ? O
10	          Do U&lt; head[Q]
11	                for всех V есть Adj[U] 
12	                     do if color[V] = белый
13	                              then color[V] = серый
14	                                      d[V]&lt;d[U]+1
15	                                       ?[V] &lt; U
16	                                       ENQUEUE(Q,V)
17	                 DEQUEUE(Q)
18	                 color[U] &lt; черный<br></pre>
<p>В строках 1-4 все вершины становятся белыми, все значения d бесконечными, а 
  родители всех вершин - NIL.</p>
<p>Строки 5-8 красят вершину S в серый цвет, d[S]=0, отца в S нет; S становится 
  в очередь Q</p>
<p>9-18 выполняются пока есть серые вершины. В 10 строке первая такая вершина 
  вмещается в U. Цикл for в 11-16 просматривает все сопредельные с ней вершины. 
  Проявив среди них белую, мы делаем ее серой( строка 13), декларируем U ее отцом( 
  строка 15) и устанавливаем ее длину как d[U]+1( строка 14). Эта вершина устанавливается 
  в хвост очереди( строка 16). После этого вершина U удаляется из очереди Q, она 
  красится в черный цвет( строки 17-18).</p>
<h3>Упражнения. </h3>
<ol>
  <li> Напишите процедуру BFS, если граф представлен в виде матрицы смежности. 
  </li>
  <li>Пусть G=(V,E) - неориентированный граф. Придумайте алгоритм, который отыскивает 
    путь в графе, который проходит каждое ребро ровно по одному разу в каждую 
    сторону.</li>
  <li>Задан граф G=(V,E) с начальной вершиной S. Рассматривается подграф, вершинами 
    которого есть доступные с S вершины, а ребрами есть (?[V],V) для всех доступных 
    V, кроме S. Постройте алгоритм, который находит кратчайшие пути из S в V.<br>
  </li>
</ol>
<h3>Минимальные покрытия дерева.</h3>
<p>Пусть G=(V,E) связный неориентированный граф. Для каждого ребра графа (U,V) 
  задано неотемлемое значение (вес) w(U,V). Общий вес графа Т є w(T) = ?w(U,V). 
  Связный граф подграфа G, что является деревом (U,V) есть Т и содержит в себе 
  все вершины графа, называют покрывающим деревом. Дерево, которое имеет минимальный 
  общий вес, называют минимальным покрывающим деревом.</p>
<p>Построение минимального покрывающего дерева( минимальный остов) выполняется 
  алгоритмом Generic_MST(G,w), где G - граф, w - его весовые функции(E&gt;R).Искомый 
  остов строится пошаговая: к пустому множеству А на каждом шаге прибавляется 
  одно ребро. Множество А всегда является подмножеством некоторого минимального 
  остова. Ребро (U,V), добавляем на текущем шаге,выбирается так, чтобы не нарушить 
  это свойство: A U {(U,V)} также должно быть подмножеством минимального остова. 
  Называют такое ребро безопасным ребром.</p>
<pre>Generic_MST(G,w)
1	A &lt; O
2	while А не является остов
3	        do найти безопасное ребро (U,V) для А
4	            А &lt; A U {(U,V)} 
5	return A</pre>
<p>Алгоритмы Крускала и Прима строят минимальные покрывая дерева. В алгоритме 
  Крускала множество ребер А подает лес, который состоит из нескольких связных 
  компонент(деревьев). Прибавляется к А ребро минимального веса среди всех ребер, 
  концы которых лежат в разных компонентах.</p>
<p>В алгоритме Прима множество А представлена одним деревом. Безопасное ребро, 
  которое прибавляется к А, выбирается, как ребро минимального веса, который соединяет 
  уже построеное дерево с новой вершиной.</p>
<h3>Упражнения.</h3>
<ol>
  <li> Рассмотрите алгоритм Крускала в литературном источнике( что имеется). Продемонстрируйте 
    его работу на придуманном вами графе.</li>
  <li>Сделайте тоже самое, что и в 1., но с алгоритмом Прима.</li>
  <li>Проанализируйте работу алгоритма Белмана-Форда на придуманном вами графе 
    с поиском кратчайших путей из одной вершины. Алгоритм возьмите из литературного 
    источника.</li>
  <li>Сделайте тоже самое, что и в 3., но с алгоритмом Флойда-Уоршола по поиску 
    кратчайших путей для всех пар вершин.<br>
  </li>
</ol>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Лекция №8.htm">Вернуться на лекцию</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
