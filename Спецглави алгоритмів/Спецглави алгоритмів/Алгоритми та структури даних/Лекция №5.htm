<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №6</h2>
<h2 align="center">Тема: Не эффективные рекурсии. Решение рекурсивных соотношений.</h2>
<p>Рекурсивные программы могут иметь хорошие временные характеристики, как это 
  следует из предыдущей лекции. Функции, которыми определяются эти характеристики, 
  задаются рекуррентными соотношениями типа T(n)=aT(n/b)+f(n), где a, b – константы 
  a=&gt;1, b&gt;1, f(n) – известная функция. Под n/b подразумеваются функции <img src="img/LNC.GIF" width="10" height="20">n/b<img src="img/PNC.GIF" width="10" height="20">, 
  <img src="img/LVC.GIF" width="8" height="20">n/b<img src="img/PVC.GIF" width="9" height="20">. 
  В предыдущей лекции был рассмотрен метод решения рекурсивных соотношений, который 
  называется методом итераций.</p>
<p>Еще один метод решения использует математическую индукцию. В этом методе необходимо 
  угадать решение, затем показать, что это решение годится для минимального значения 
  объема входных данных, предположить верность решения для объема входных данных 
  “k” и доказать верность решения для объема k+1.</p>
<p>Рассмотрим применение этого метода на примере, для чего вернемся к рекуррентному 
  соотношению T(n)=2T(n/2)+n, но уже в виде:</p>
<p><br>
  T(n)=2T(<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">)+n 
  (5.1) </p>
<p>Т. е. Мы уже не полагаем, что n=2<sup>k</sup>. Покажем методом математической индукции, 
  что решением (5.1) по прежнему является функция n log n. Докажем, что</p>
<p>T(n)=O(n log n). (5.2)</p>
<p>В соответствии с определением функции O имеем:</p>
<p>T(n)=c n log n (5.3)</p>
<p>Доказательство теперь проведем для (5.3).</p>
<p>1) Для объема входных данных n=1 имеем из (5.3) T(1)&lt;=c log 1 , т. е. T(1)&lt;=0, 
  что неверно, т. к. T(1) выполняется за константное время. Учитывая определение 
  для функции O, вводим n0 (минимальное), для которого соотношение (5.2) будет 
  выполняться. Возьмем n0=2. Из (5.1) T(2)=2T(1)+2. Т. к. T(1)=1, T(2)=4. Таким 
  образом T(2)&lt;=c 2 log 2, или 4&lt;=2c. Последнее неравенство выполняется 
  при c=2, что и доказывает базис итерации.</p>
<p>2) Полагаем, что (5*2) выполняется для k=<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">, 
  т.е.</p>
<p>T(<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">)&lt;=C<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">log(<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">). 
  (5.3)</p>
<p>3) В нашем случае k+1 – это n. Из (5.1) и (5.4) с учетом <img src="img/LNC.GIF" width="10" height="20">x<img src="img/PNC.GIF" width="10" height="20">&lt;=x 
  имеем: T(n)=2T(<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">)+n&lt;=2(C<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">log(<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">))+n&lt;=2C(n/2)*(log 
  n-log 2)+n=C*n*log n-Cn+n, что при С=1 дает n log n. Т.е. мы получили T(n)&lt;=C*n*log 
  n, что и доказывает (5.2).</p>
<p>Однако рекурсивные алгоритмы могут иметь плохие временные характеристики типа 
  2<sup>n</sup>. Рассмотрим пример, который известен как задача “Ханойские башни”. Имеются 
  три стержня (А, В, С). На стержне А находятся диски, расположенные так, как 
  показано на рис 5.1<br>
</p>
<p align="center"><img src="img/6vRis1.GIF" width="593" height="200"><br>
  Рис 5.1. Постановка задачи “Ханойские башни”. </p>
<p>Задача состоит в том, чтобы переместить диски со стержня А на стержень В. Перемещение 
  выполняется шагами. За один шаг может быть перенесен только один диск. При выполнение 
  шага нельзя класть диск большего диаметра на диск меньшего диаметра, но можно 
  положить диск меньшего диаметра на диск большего. Стержень С используется как 
  промежуточный.</p>
<p>Можно предложить рекурсивное решение этой задачи: если на стержне А находится 
  n дисков, переносим (n-1) диск на стержень С, затем помещаем самый большой диск 
  с А на В, А затем перемещаем (n-1) диск со стержня С на В. Запишем это решение 
  в виде алгоритма. Обращение к этому алгоритму: Башня (n, А, В, С), где n – число 
  дисков, находящихся на А, Которые нужно переместить на В, используя С как промежуточный.<br>
</p>
<pre>Башня (n, А, В, С)
                                 цена
1.	if n=0                        Q(1)
2.	   then return                Q(1)
3.	Башня (n-1, С, В, А)          T(n-1)
4.	Перемещение (А, В)            Q(1) 
5.	Башня (n-1, С, В, А)          T(n-1)
</pre>
<p>Продемонстрируем как работает алгоритм при n=3:</p>
<p><img src="img/6vRis2.GIF" width="659" height="544"></p>
<p>После перемещения диска 3 должен работать вызов Башня (2,С,В,А), который и 
  осуществит перенос оставшихся дисков со стержня С на стержень В.</p>
<p>Проводя эксперименты над алгоритмом Башня, можно заметить, что диск с номером 
  1 участвует в каждом втором переносе, диск с номером 2 – в каждом 4, с номером 
  3 – в каждом 8 и т.д. Т.е. количество перемещений есть сумма степеней числа 
  2.</p>
<p>Оценим сложность алгоритма башня. Для этого сделаем оценку каждой строки алгоритма. 
  Строки 1, 2, 4 выполняются за константное время Ө(1)=1. Строка 3 есть рекурсивный 
  вызов этого же алгоритма с объемом данных n-1. Если сложность алгоритма есть 
  T(n), то строка 3 оценивается как T(n-1). По этой же причине строка 5 оценивается 
  как T(n-1). Общая оценка алгоритма Башня есть </p>
<p>T(n)=2T(n-1)+1 (5.5).</p>
<p>Положим, что T(n)=2<sup>n</sup>-1, и докажем это методом математической индукции.</p>
<p>1) n=1 T(1)=2-1=1, т.е при перемещении одного диска необходимо константное 
  время. </p>
<p>2) n=k. Считаем, что верна формула</p>
<p>T(k)=2<sup>k</sup>-1 (5.6)</p>
<p>3) n=k+1. Учитывая (5.5) и (5.6) имеем.</p>
<p>T(k+1)=2T(k)+1=2*(2<sup>k</sup>-1)+1=2<sup>k+1</sup>-1.</p>
<p>Что и доказывает допущение.</p>
<p>Таким образом, алгоритм башня имеет экспоненциальную сложность, что указывает 
  на практическую его нереализуемость для относительно небольшого (64) объема 
  входных данных. Такая рекурсия не может считаться эффективной. </p>
<p>Однако рекурсия – весьма полезное свойство, позволяющее выявить определенные 
  закономерности в обработке данных и составить евклидовую итеративную программу 
  эквивалентную рекурсивной.</p>
<p>Рекурсивные программы должны быть корректными в плане обязательного их завершения. 
  Рассмотрим алгоритм, реализующий следующую функцию func(n), аргументом которой 
  является натуральное число. Значение функции вычисляется: если n=1, то func(n)=1; 
  если n – четное, то значение вычисляется как func(3*т+1).<br>
</p>
<pre>func(n).
1.	if n=1
2.	     then return 1
3.	if n%2=0
4.	     then return func(n/2)
5.	     else return func(3*n+1) 


Здесь n%2 – остаток от деления n на 2.
Пример функционирования func(3):
	func(3)
	   func(10) 
		  func(5)
		     func(16)
			    func(8)
			       func(4) 
				      func(2)
				         func(1) 
</pre>
<p>Результатом работы алгоритма func будет 1, если алгоритм завершается. Но в 
  этом примере рекурсия организована так, что нет стопроцентной уверенности в 
  том, что в прочесе рекурсивного вычисления получится 1, представляющая базис 
  рекурсии и обеспечивающая завершение алгоритма.</p>
<p>При построении рекурсивных алгоритмов базис рекурсии нужно строить так, чтобы 
  был гарантирован выход из рекурсии.</p>
<h3>Контрольные вопросы.</h3>
<ol>
  <li> Из – за чего рекурсивный алгоритм может иметь экспоненциальную сложность?</li>
  <li>Какова гарантия благополучного завершения рекурсивного алгоритма.</li>
  <li>Сформулируйте определение математической индукции и самостоятельно докажите 
    (5.5).</li>
  <li>Постройте дерево, отражающее рекурсивные обращения при решении задачи о 
    ханойских башнях при n=4.<br>
  </li>
</ol>
<p>&nbsp; </p>
<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
