<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №7</h2>
<h2 align="center">Тема: Применение динамического программирования для составления 
  алгоритма.</h2>
<p>Метод динамического программирования позволяет решить задачу, разбивая ее на 
  подзадачи и объединяя решение подзадач. В этом плане динамическое программирование 
  схоже с методом разделяй и властвуй, где задачи также разбиваются на подзадачи, 
  а затем подзадачи собираются в общее решение. Однако при методе “разделяй и 
  властвуй” задача делится на независимые подзадачи, при динамическом программировании 
  подзадачи не являются независимыми, т.е. у подзадач есть общие “подподзадачи”. 
  Рекурсивный алгоритм (разделяй и властвуй), решает общие подзадачи по нескольку 
  раз. Алгоритм, основанный на динамическом программировании, решает каждую из 
  подзадач единожды и запоминает результаты в специальной таблице. Это позволяет 
  не вычислять заново результат уже единожды решенной подзадачи. </p>
<p>В типичном случае динамическое программирование применяется к задачам оптимизации. 
  У такой задачи может быть множество решений; их “качество” определяется значением 
  какого-то параметра, и требуется выбрать оптимальное решение, при котором значение 
  параметра будет максимальным или минимальным (в зависимости от конкретной задачи). 
  Вообще, оптимум может достигаться для нескольких разных решений.</p>
<p>Для построения алгоритма, основанного на динамическом программировании надо:</p>
<ol>
  <li> описать строение оптимальных решений;</li>
  <li>выписать рекуррентное соотношение, связывающее оптимальные значения параметра 
    для подзадач;</li>
  <li>вычислить оптимальное значение параметра для всех подзадач;</li>
  <li>пользуясь вычисленной информацией построить оптимальное решение.</li>
</ol>
<p>Динамическое программирование предполагает пошаговый прочес, где первая подзадача 
  решается с последнего шага. Находится оптимальное решение на последнем шаге, 
  Затем оптимальное решение на предпоследнем шаге такое, чтобы оптимальное решение 
  предпоследнего и последнего шагов дало общий оптимум. Трех шаговое решение получается 
  путем добавления результатов предыдущего (третьего) шага. Этот прочес продолжается, 
  пока не будет назван оптимум на первом шаге такой, чтобы общий оптимум первого 
  шага и полученный уже оптимум предыдущих шагов был обеспечен.</p>
<p>Рассмотрим процесс составления алгоритма с применением динамического программирования 
  для решения задач о наборе высоты и скоростей летательным аппаратом.</p>
<p>Формулировка задачи.</p>
<p>Пусть летательный аппарат находится на высоте h<sub>0</sub> и обладает скоростью 
  V<sub>0</sub>. Аппарат необходимо поднять на высоту h<sub>w</sub> при скорости 
  V<sub>w</sub>. Известен расход горючего для подъема или набора скорости на необходимом 
  участке: известен расход топлива в условных единицах для подъема с h на h’=h+∆h 
  (V=const) и для достижения V’ от V(V’=V+∆V, h=const).</p>
<p>Найти оптимальный режим набора высоты и скорости, при котором общий расход 
  топлива будет минимальным.</p>
<p>Таким образом, необходимо найти траекторию изменения высоты и скорости в координатах 
  V, h.</p>
<p>Можно попытаться решить задачу методом перебора всех траекторий и выбора нужной, 
  с минимальным расходом топлива. Однако количество возможных траекторий растет 
  экспоненциально с ростом n, где n – количество участков, на которых задан удельный 
  расход топлива (∆V=(V<sub>w</sub>-V<sub>0</sub>)/n , ∆h=(h<sub>w</sub>-h<sub>0</sub>)/n).</p>
<p>На рис 6.1 приведена координатная сетка в координатах (V, h), задающая участки 
  удельного расхода топлива и отмечены две из возможных траекторий.</p>
<p align="center"><img src="img/7vRis1.GIF" width="495" height="275"><br>
  Рис 6.1. Формулировка задачи в пространстве состояний S. </p>
<p>Существует множество траекторий для перевода состояния S<sub>0</sub> в S<sub>w</sub>, но среди них 
  есть оптимальные (их, кстати, может быть несколько). Чтобы оптимизировать расход 
  топлива нужно знать его удельное потребление на каждом шаге, т.е. нужно связать 
  состояние S в каждой точке (V,h) с удельным расходом по высоте и по скорости. 
  Такое связывание приведено на рис. 6.2 . Здесь каждое состояние S<sub>i</sub> представлено 
  кружком, внутри которого указан минимальный расход топлива для локального участка 
  траектории. Вся траектория состоит из 13 шагов. На каждом шаге стрелкой указанно, 
  в каком направлении получается минимум топлива (в вертикальном иле горизонтальном). 
  Минимальный расход топлива для всей траектории задается состоянием S<sub>0</sub> (127).</p>
<p>Рассмотрим, как вычисляются локальные минимумы(Рис.6.1).<br>
</p>
<p align="center"><img src="img/7vRis2.GIF" width="582" height="545"></p>
<p align="center">Рис.6.2. Удельный расход топлива и локальнее минимумы на каждом 
  шаге.</p>
<p>Стрелки указывают направление локального минимума и траекторию состояний.</p>
<p>В соответствии с принципом динамического программирования решение задачи начинаем 
  с конца. Рассмотрим состояния, из которых мы можем послать в S<sub>w</sub> за 
  один шаг:</p>
<p align="center"><img src="img/7vRis3.GIF" width="401" height="156"></p>
<p>Чтобы попасть в S<sub>w</sub> из точки B<sub>1</sub> необходимо израсходовать 17 единиц топлива и 
  двигаться по горизонтали. Из точки B<sub>2</sub> – 14 единиц и движение по вертикали. Направления 
  движения указываются стрелкой.</p>
<p>Рассмотрим фрагмент двухшагового процесса. <br>
</p>
<p align="center"><img src="img/7vRis4.GIF" width="208" height="178"></p>
<p>Чтобы попасть из точки C в S<sub>w</sub>, нужно пройти либо точку B<sub>1</sub> либо точку B<sub>2</sub>. Если 
  идти через B<sub>1</sub>, общий расход топлива будет 30, а через B<sub>2</sub> – 31. Минимум получится 
  через B<sub>1</sub>, т.е. 30. Поэтому в кружке, обозначающем точку С записываем 30 и указываем 
  стрелкой направление к B<sub>1</sub>. Таким же образом производится выбор для каждой точки 
  координатной системы.</p>
<p>В результате вычисления локальных минимумов в каждой точке координатной сетке 
  получится матрица, представленная на рис.6.2. каждый элемент этой матрицы состоит 
  из двух компонент: минимального расхода топлива от текущего шага до конца указателя.</p>
<p>Как показывает выше приведенный анализ задачи, вычисление локальных оптимумов, 
  начиная с последнего шага, можно производить путем выбора минимума, для некоторого 
  состояния, из двух чисел – расхода топлива по вертикали и горизонтали.</p>
<p>Для построения алгоритма, вычисляющего минимум, составим рекурсивные соотношения. 
  При этом будем полагать, что результаты вычислений будут записываться в двумерную 
  матрицу m[i, j], где i, j – градации координатной сетки, соответствующие h<sub>0</sub>, 
  h<sub>0</sub>+∆h, h<sub>0</sub>+2∆h,…,U<sub>0</sub>, U<sub>0</sub>+∆U, U<sub>0</sub>+2∆U,… Пусть нумерация для i осуществляется сверху 
  вниз (1,2,…,k) для i – слева на право (1,2,…,l).</p>
<p>Для состояния S<sub>w</sub> имеем:<br>
</p>
<p>M[1,l]=0     (1)</p>
<p>Для состояния C i=1:</p>
<p>M[1,j]=m[1,j+1]+∆U (2)</p>
<p>Где ∆U – расход топлива по горизонтали в точке (i,j).</p>
<p>Для состояния C j=l:</p>
<p>M[i,l]=m[i-1,l]+∆h (3)</p>
<p>Где ∆h – расход топлива по вертикали в точке (i,l).</p>
<p>Для всех остальных состояний </p>
<p>M[i,j]=min{m[i,j+1]+∆U, m[i-1,j]+∆h} (4)</p>
<p>Формулы (1) – (4) представляют собой рекуррентные соотношения для вычисления 
  локальных минимумов в матрице m[i, j]. Глобальный минимум будет находиться в 
  элементе m[k,1]. Для нахождения траектории в пространстве состояний введем матрицу 
  S[i, j], куда будем записывать метки, указывающие направление движения. Если 
  в m[i, j] минимум получается для набора высоты (∆h), то в S[i, j] ,eltv будем 
  записывать “h”. Если же минимум определяет скорость (∆U), то S[i, j] приобретает 
  “U”. Траекторию можно найти, просматривая матрицу S, начиная с элемента S(k,1). 
  Для хранения значений ∆U и ∆h введем массив BX[i, j, k]. BX[i, j, 1] – содержит 
  ∆U для точки (i, j), а BX[i, j, 2] - ∆h.</p>
<p>Алгоритм, реализующий формулы (1) – (4).</p>
<pre>Счет_m_S (BX)<br>1.	m[1, k]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">0<br>2.	for j<img src="img/ctrelka_v_levo.GIF" width="22" height="14">l-1 downto 1<br>3.	     do m[1, j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m[1, j+1]+BX[i, j, 1]<br>4.	for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">2 to k<br>5.	     do m[i, l]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m[i-1, l]+BX[i, j, 2]<br>6.	for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">2 to k <br>7.	     do for j<img src="img/ctrelka_v_levo.GIF" width="22" height="14">l-1 downto 1 <br>8.	          do ZNV<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m[i, j+1]+BX[i, j, 1]<br>9.	               ZNH<img src="img/ctrelka_v_levo.GIF" width="22" height="14">m[i-1, j]+BX[i, j, 2]<br>10.	               if ZNV&lt;ZNH<br>11.	                    then m[i, j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">ZNV<br>12.	                         S[i, j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">’V’
13.	                    else m[i, j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">ZNH<br>14.	                          S[i, j]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">’H’<br>15.	return m, S<br></pre>
<p>Для части координатной строки, представленной здесь ниже.</p>
<p align="center"><img src="img/7vRis5.GIF" width="323" height="264"></p>
<p>Матрицы m и S, вычисленные в соответствии с алгоритмом Счет_m_S имеет вид:</p>
<p>Матрица m для k=4, l=5:</p>
<table width="400" border="1">
  <!--DWLayoutTable-->
  <tr> 
    <td>&nbsp;</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
  </tr>
  <tr> 
    <td>1</td>
    <td>58</td>
    <td>44</td>
    <td>32</td>
    <td>17</td>
    <td>0</td>
  </tr>
  <tr> 
    <td>2</td>
    <td>68</td>
    <td>57</td>
    <td>44</td>
    <td>30</td>
    <td>14</td>
  </tr>
  <tr> 
    <td>3</td>
    <td>69</td>
    <td>60</td>
    <td>52</td>
    <td>41</td>
    <td>26</td>
  </tr>
  <tr> 
    <td>4</td>
    <td>77</td>
    <td>70</td>
    <td>63</td>
    <td>51</td>
    <td>35</td>
  </tr>
</table>
<p>Матрица S для k=4, l=5: </p>
<p><img src="img/7vRis6.GIF" width="401" height="126">
</p>
<p>В матрице S схематически (стрелкой) показана траектория движения летательного 
  аппарата на выбранном участке.</p>
<p>Сложность алгоритма Счет_m_S определяется двойным циклом и является квадратичной. 
  Если положить, что n – наибольшая размерность матрицы m, то T(n)=Ө(n<sup>2</sup>).<br>
</p>
<h3>Контрольные вопросы.</h3>
<ol>
  <li> Перечислите этапы которые необходимо выполнить при использовании динамического 
    программирования для конструирования алгоритма.</li>
  <li>Почему не следует использовать полученное рекуррентное соотношение для решения 
    задачи рекуррентным алгоритмом?</li>
  <li>Проанализируйте, какие операции выполняются на этапе вычисления и что используется 
    для построения алгоритма вычисления.</li>
  <li>Какая матрица используется для получения окончательного результата?<br>
  </li>
</ol>
<p>&nbsp;</p>
<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
