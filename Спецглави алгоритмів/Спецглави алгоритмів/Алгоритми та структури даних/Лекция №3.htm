<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №4 </h2>
<h2 align="center">Тема: Анализ алгоритмов.</h2>
<p>Одна задача может иметь для своего решения несколько алгоритмов. Рассматривая 
  эти алгоритмы, их анализируют, сколько вычислительных процессов (время работы, 
  память) они требуют. Выбирают наиболее эффективный. Методика анализа алгоритмов, 
  которая рассматривается ниже, предполагает, что алгоритм выполняется на однопроцессорной 
  машине с произвольным доступом (RAM), и не предусматривается параллельное выполнение 
  операций. </p>
<p>Наиболее употребительной характеристикой алгоритма является его сложность, 
  т.е. функция роста времени от объема входных данных. Рассмотрим методику нахождения 
  сложности алгоритма для алгоритмов, составленных пошаговым методом посредством 
  циклов for, while.</p>
<p>Размер объем входа зависит от конкретной задачи. В одних случаях – это число 
  элементов на входе (сортировка), в других более естественно считать размером 
  общее число битов, необходимое для представления входных данных. Иногда размер 
  входа измеряется не одним числом, а несколькими (число вершин и ребер графа).</p>
<p>Временем работы алгоритма называется число элементарных шагов, которые он выполняет. 
  Будем полагать, что строка псевдокода требует не более чем фиксированного числа 
  операций, если только это не словесное описание каких-то сложных действий. Будем 
  также различать вызов процедуры, на который уходит фиксированное число операций, 
  и ее исполнение, которое может быть долгим и иметь свою сложность.</p>
<p>Вернемся теперь к алгоритму Sort_Vstk, представленному в предыдущей лекции. 
  Отметим около каждой строки ее стоимость (число операций) и число раз, которое 
  эта строка исполняется. Для каждого j от 2 до n (здесь n=length[A] – размер 
  массива) подсчитаем, сколько раз будет выполнена строка 4, и обозначим это число 
  через t<sub>j</sub>. Заметим , что строки внутри цикла выполняются на один раз 
  меньше, чем заголовок цикла, поскольку последняя проверка выводит из цикла.</p>
<p> Sort_Vstk(А).</p>
<table width="50%" border="1">
  <tr>
    <td>№</td>
    <td>Элемент кода</td>
    <td>Стоимость</td>
    <td>Число раз</td>
  </tr>
  <tr>
    <td>1</td>
    <td>for j<img src="img/ctrelka_v_levo.GIF" width="22" height="14">2 to length[A] 
    </td>
    <td>C<sub>1</sub></td>
    <td>n</td>
  </tr>
  <tr>
    <td>2</td>
    <td>do key<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[j]</td>
    <td>C<sub>2</sub></td>
    <td>n-1</td>
  </tr>
  <tr>
    <td>3</td>
    <td> i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">i-1</td>
    <td>C<sub>3</sub></td>
    <td>n-1</td>
  </tr>
  <tr>
    <td>4</td>
    <td>while i>0 and A[i]>key</td>
    <td>C<sub>4</sub></td>
    <td><img src="img/4vRis1.GIF"></td>
  </tr>
  <tr>
    <td>5</td>
    <td>do A[i+1]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[i]</td>
    <td>C<sub>5</sub></td>
    <td><img src="img/4vRis2.GIF"></td>
  </tr>
  <tr>
    <td>6</td>
    <td> i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">i-1 </td>
    <td>C<sub>6</sub></td>
    <td><img src="img/4vRis2.GIF" width="109" height="78"></td>
  </tr>
  <tr>
    <td>7</td>
    <td> A[i+1]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">key</td>
    <td>C<sub>7</sub></td>
    <td>n-1</td>
  </tr>
</table>
<p><br>
  Строка стоимостью С, повторенная m раз дает C<sub>m</sub> операций. Сложив стоимость 
  всех строк, получим функцию T(n) – сложность алгоритма. Для алгоритма Sort_Vstk 
  имеем:<br>
  <br>
  <img src="img/4vRis3.GIF" width="746" height="87"> </p>
<p>В (3.1) T(n) определяется не только через n, но и через переменную t<sub>j</sub>, которая 
  отражает количество повторений цикла while. Количество же повторений этого чикла 
  зависит от массива, поданного на вход. Рассмотрим два случая входных массивов 
  (лучший и худший).</p>
<p>Самый благоприятный случай для алгоритма Sort_Vstk, когда на его вход подан 
  уже отсортированный массив. Тогда цикл в строке 4 завершается всегда после одного 
  повторения для всех j. Т.е. t<sub>j</sub>=1. Формула (3.1) превращается в </p>
<p>T(n)=C<sub>1</sub>+C<sub>2</sub>(n-1)+ C<sub>3</sub>(n-1)+C<sub>4</sub>n+C<sub>7</sub>(n-1)=
(C<sub>1</sub>+C<sub>2</sub>+C<sub>3</sub>+C<sub>4</sub>+C<sub>7</sub>)n+(-C<sub>2</sub>-C<sub>3</sub>-C<sub>7</sub>)=an+b</p>
<p>Где a= C<sub>1</sub>+C<sub>2</sub>+C<sub>3</sub>+C<sub>4</sub>+C<sub>7</sub> , b=-C<sub>2</sub>-C<sub>3</sub>-C<sub>7</sub> .</p>
<p>Т.е. в этом случае сложность алгоритмов оценивается линейной функцией.</p>
<p>Худший случай получается, когда исходный массив расположен в обратном (убывающем) 
  порядке. Каждый элемент A[j] придется сравнить со всеми элементами A[1], … ,A[j-1]. 
  При этом t<sub>j</sub>=j и формула (3.1) превращается в:<br>
</p>
<p><img src="img/4vRis4.GIF" width="714" height="77"></p>
<p>Оценим суммы от j в (3.2), которые представляют собой суммы арифметических 
  прогрессий. Т.к. формула суммы арифметической прогрессии<img src="img/4vRis5.GIF" width="119" height="54">, 
  сумма <img src="img/4vRis6.GIF" width="194" height="81">, а <img src="img/4vRis7.GIF" width="207" height="76">. 
  Подставив значения найденных сумм в (3.2) получаем: </p>
<p><img src="img/4vRis8.GIF" width="631" height="128"></p>
<p>Теперь функция T(n)=a<sup>2</sup>+bu+c, т.е. квадратичная (константы a, b, c определяются 
  через C<sub>1</sub>, C<sub>2</sub>, …, C<sub>7</sub>).</p>


<h3>Время работы в худшем случае и в среднем.</h3>
<p>Из вышеизложенного видно, что время работы алгоритма в лучшем и худшем случае 
  могут значительно отличаться. Большей частью интересуется сложностью алгоритма 
  в худшем случае, которая определяется как максимальное время работы для входов 
  данного размера. Здесь ниже перечислены, из-за которых производится такой выбор.</p>
<p>Зная время работы в худшем случае, мы можем гарантировать, что выполнение алгоритма 
  закончится за некоторое время, даже не зная, какой именно вход (размер) попадется.</p>
<p>На практике “плохие входы” (для которых время работы близко к максимуму) могут 
  часто попадаться. Например, для базы данных плохим запросом может быть поиск 
  отсутствующего элемента (довольно частая ситуация). </p>
<p>Время работы в среднем может быть довольно близко к времени работы в худшем 
  случае. Пусть, например, сортируются случайно расположенные n чисел с помощью 
  алгоритма Sort-Vstk. Сколько раз придется выполнить цикл в строках 4-6? В среднем 
  около половины элементов массива A[1..j-1] больше A[j], так что t<sup>j</sup> 
  в среднем можно считать равным j/2, и время T(n) квадратично зависит от n.</p>
<p>Проведенный выше анализ работы алгоритма Sort-Vstk был основан на нескольких 
  упрощающих предположениях. Сначала предполагалось, что время выполнения i-й 
  строки постоянно и равно C<sub>i</sub>. Затем огрубили оценку до an<sub>2</sub>+bn+c. 
  Сделаем еще одно предположение, Что время работы в худшем случае имеет порядок 
  роста n<sup>2</sup>, отбрасывая члены меньших порядков (линейные). Это правомочно 
  для больших объемов входных данных.</p>
<p>Методика, предложенная для нахождения Т(n) в алгоритме сортировки годится для 
  алгоритмов составленных пошаговым методом (с использованием циклов). Анализируя 
  алгоритм, можно стараться найти точное количество выполняемых им действий. Но 
  в большинстве случаев такая информация мало полезна. Более информативна асимптотика 
  роста времени работы алгоритма при стремлении размера входа к бесконечности. 
  Если имеются два алгоритма, решающие одну и ту же задачу, и у одного алгоритма 
  асимптотика роста меньше, чем у другого, то в большинстве случаев он будет эффективнее 
  для всех входов, кроме совсем коротких .</p>
<h3>Асимптотические обозначения. </h3>
<p>Асимптотика роста времени от объема входа характеризуется следующими функциями, 
  называемыми асимптотическими. Наиболее употребляемыми являются функции Ө, O, 
  <img src="img/Om.GIF" width="21" height="16">.</p>
<p>Определение 1. T(n)= Ө(q(n)), где q(n) – некоторая функция, если найдутся такие 
  константы C<sub>1</sub>, C<sub>2</sub>&gt;0 и такое число n<sub>0</sub>, что 
  C<sub>1</sub>q(n)&lt;=T(n)&lt;=C<sub>2</sub>q(n) при всех n&gt;n<sub>0</sub>.</p>
<p>Ө (1) обозначает ограниченную функцию, определенную от O некоторой положительной 
  константой при достаточно больших значениях аргумента в T(n). Полагают Ө (1)=1.</p>
<p>Пример 1. Показать, что T(n)=n<sup>2</sup>/2-3n= Ө(n<sup>2</sup>).</p>
<p>В соответствии определением функции Ө имеем: C<sub>1</sub>n<sup>2</sup>&lt;=n<sup>2</sup>/2-3n &lt;=C<sub>2</sub>n<sup>2</sup> должно 
  иметь C<sub>1</sub>, C<sub>2</sub>&gt;0 и выполняться для всех n&gt;n<sub>0</sub> (т.е. иметь n<sub>0</sub>). Разделив обе 
  части системы неравенств на n<sup>2</sup>, получаем C<sub>1</sub>&lt;=1/2-3/n&lt;=C<sub>2</sub>.</p>
<p>Для выполнения этого неравенства достаточно положить C<sub>2</sub>=1/2 (для любого n) 
  и C<sub>1</sub>=1/14 для n<sub>0</sub>=7. Таким образом T(n)= Ө (n<sup>2</sup>).</p>
<p>Пример 2. Если T(n)=6n<sup>3</sup>, то T(n) не равно Ө (n<sup>2</sup>).</p>
<p>C<sub>1</sub>n<sup>2</sup>&lt;=6n<sup>3</sup>&lt;=C<sub>2</sub>n<sup>2</sup><br>
  C<sub>1</sub>&lt;=6n&lt;=C<sub>2</sub></p>
<p>Так как функция 6n монотонно растущая, нельзя указать С<sub>2</sub> такое, что 6n &lt;=C<sub>2</sub>. 
  Следовательно T(n) не равно Ө (n<sup>2</sup>).</p>
<p>Определение 2. T(n)=O(g(n)), если найдется такая константа C&gt;0 и такое число 
  n<sub>0</sub>, что O&lt;=T(n)&lt;=Cg(n).</p>
<p>Ө (q(n)) включает в себя две оценки: верхнюю и нижнюю. O и <img src="img/Om.GIF" width="21" height="16">разделяют 
  их, O – дает верхнюю оценку, <img src="img/Om.GIF" width="21" height="16">- 
  нижнюю.</p>
<p>Определение 3. T(n)=<img src="img/Om.GIF" width="21" height="16">(g(n)), если 
  найдутся такая константа C&gt;0 и n0 такие, что O&lt;=Cg(n)&lt;=T(n) для всех 
  n=&gt;n<sub>0</sub>.</p>
<p>Асимптотические обозначения имеют геометрическую интерпретацию(Рис.1)</p>
<p align="center"><br>
  <img src="img/4vRis9.GIF" width="622" height="206"> </p>
<p align="center">Рис.1. Геометрическая интерпретация асимптотических обозначений.</p>
<h3>Элементарные функции для оценки сложности алгоритма.</h3>
<ol>
  <li> [x] – наибольшее целое число, не превосходящее x;<br>
    [x] – наименьше целое число, не меньшее x;<br>
    x-1&lt;<img src="img/LNC.GIF" width="10" height="20">x<img src="img/PNC.GIF" width="10" height="20">&lt;=x&lt;=<img src="img/LVC.GIF" width="8" height="20">x<img src="img/PVC.GIF" width="9" height="20">&lt;x+1;<br>
    <img src="img/LVC.GIF" width="8" height="20">n/2<img src="img/PVC.GIF" width="9" height="20">+<img src="img/LNC.GIF" width="10" height="20">n/2<img src="img/PNC.GIF" width="10" height="20">=n 
    для любого целого n;<br>
    Эта функция определяет константу. </li>
  <li>Логарифмы. Наиболее употребителен двоичный логарифм, который обозначается 
    log n.</li>
  <li>Полином <img src="img/4vRis10.GIF" width="135" height="80">.</li>
  <li>Экспонента T(n)=a<sup>n</sup>, де a – константа. Употребительна функция 
    2<sup>n</sup>. </li>
  <li>Факториал: n!; <img src="img/4vRis11.GIF" width="228" height="57">.</li>
  <li>Числа Фибоначчи: F<sub>0</sub>=0, F<sub>1</sub>=1, F<sub>i</sub>=F<sub>i</sub>-1+F<sub>i-2</sub> 
    при I=&gt;2; <br>
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,…</li>
  <li>Известны соотношения для чисел Фибоначчи: <img src="img/Fi.GIF" width="15" height="15">=(1+<img src="img/Kor5.GIF" width="20" height="22"> 
    )/2=1,61803… , <img src="img/He.GIF" width="15" height="11"><img src="img/Fi.GIF" width="15" height="15">=(1-<img src="img/Kor5.GIF" width="20" height="22"> 
    )/2=-0,61803… ;<br>
    Fi=(<img src="img/Fi.GIF" width="15" height="15">i-<img src="img/He.GIF" width="15" height="11"><img src="img/Fi.GIF" width="15" height="15">i)/<img src="img/Kor5.GIF" width="20" height="22"> 
    <br>
  </li>
</ol>
<p>Функции константа, логарифм и полином считаются приемлемыми по ресурсам для 
  оценки сложности алгоритмов. Функции экспонента, факториал, числа Фибоначчи 
  являются быстрорастущими и считаются плохими в сложностных оценках.</p>
<h3>Контрольные вопросы.</h3>
<ol>
  <li>Проанализируйте метод получения математической зависимости, характеризующей 
    сложность алгоритмов. Какой функцией характеризуется сложность при простом 
    вложенном цикле.</li>
  <li>Что такое асимптотическое обозначение для характеристики временной сложности.</li>
  <li>Дайте определение Ө (n).</li>
  <li>Дайте определение O(n).</li>
  <li>Что геометрически характеризует Ө (n), O(n), <img src="img/Om.GIF" width="21" height="16">(n).<br>
  </li>
</ol>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Лаб №1.htm">Лабораторная работа №1. Исследование временных характеристик алгоритмов.</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
