<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h1 align="center">ЛАБОРАТОРНАЯ РАБОТА №3</h1>
<h2>ТЕМА: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Создание графов и обход вершин.</h2>
<h2>ЦЕЛЬ РАБОТЫ: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Изучить варианты представления графа и научиться составлять алго-ритмы 
  обхода графа.</h2>
<h3>&nbsp;</h3>
<h3 align="center">1 ОБЩИЕ ПОЛОЖЕНИЯ</h3>
<p>1.1 Общая информация</p>
<p>Графом называется схема из некоторого множества точек и линий, соединяющих 
  эти точки. Точки называются вершинами графа, линии – дугами.</p>
<p>G(V,E)</p>
<p>G – граф, </p>
<p>V – множество вершин (для графа на рисунке 1 это {1, 2, 3, 4, 5}),</p>
<p>E – множество дуг графа (на примере это {a, b, c, d, e, f, g}).</p>
<p>Если некоторое ребро e объединяет две вершины Vi и Vk, то Vi и Vk – инцидентны 
  ребру e. Также вершины Vi и Vk в этом случае называются смежными.</p>
<p>Петлей называется ребро, инцидентное одной вершине.</p>
<p>Ребро, имеющее направление, называется дугой.</p>
<p>Граф, ребрам которого приписаны направления, называется ориентированным.</p>
<p>Нуль-граф – граф, множество ребер которого пустое.</p>
<p>Полный граф – граф, в котором все вершины соединены между собой (т.е. любая 
  пара вершин смежная).</p>
<p>Подграф – любая часть графа, сама являющаяся графом.</p>
<p>Рассмотрим 2 варианта представления графа – в виде списка смежных вершин и 
  в ви-де матрицы смежности.<br>
</p>
<p><img src="img/11Lab_Ris1.GIF" width="182" height="143"></p>
<p>Рис. 1 – Пример графа</p>
<h3>1.2 Список смежных вершин</h3>
<p>Представление графа в виде списка смежных вершин предпочтительнее в тех случаях, 
  когда число ребер E много меньше V<sup>2</sup>. </p>
<p>Граф представляется в виде некоторого массива списков. Каждый элемент массива 
  соответствует вершине графа, а список, связанный с этим элементом, – смежные 
  ей верши-ны. Каждый элемент списка содержит номер смежной вершины и признак 
  того, является ли эта вершина последней в списке. Для графа, приведенного на 
  первом рисунке, список пред-ставлен на рисунке 2 (символом &quot;*&quot; отмечен 
  признак конца списка).
</p>
<p><img src="img/11Lab_Ris2.GIF" width="333" height="187"></p>
<p>Рис. 2 – Список смежных вершин</p>
<h3>1.3 Матрица смежности</h3>
<p>Представление в виде матрицы смежности характерно для компактных графов, т.е. 
  графов, у которых E ~ V<sup>2</sup>.</p>
<p>Матрица смежности представляет собой квадратную матрицу размером NxN, где N 
  – количество вершин.</p>
<p>Строки и столбцы матрицы нумеруются в соответствии с номерами вершин. Элемент 
  матрицы ai,k, лежащий на пересечении i-й строки и k-го столбца, содержит количество 
  дуг, соединяющих i-ю и k-ю вершины. Для графа на рисунке 1 матрица смежно-сти 
  представлена на рисунке 3.</p>
<p><img src="img/11Lab_Ris3.GIF" width="161" height="156"></p>
<p>Рис. 3 – Матрица смежности</p>
<h3>1.4 Алгоритм обхода графа</h3>
<p>Рассмотрим алгоритм обхода графа, основанный на методе поиска &quot;в глубину&quot;. 
  Цель задачи – пройти по всем вершинам графа и выдать список его вершин (в порядке 
  обхода графа). В процессе обхода удобно помечать вершины тремя цветами, например, 
  белым, серым и черным. Белым цветом отмечаются еще не пройденные вершины, серым 
  – пройденные, но имеющие еще смежные не пройденные вершины, а черным – пройденные 
  и не имеющие смежных не пройденных вершин. В самом начале все вершины помечаются 
  белым цветом. Алгоритм следующий:</p>
<ol>
  <li>Выбираем одну из вершин (обычно за основу берется первый элемент в списке 
    смежных вершин или первая строка в матрице смежности);</li>
  <li>Помечаем вершину серым цветом;</li>
  <li>Проверяем, имеет ли вершина смежные ей вершины, помеченные белым цветом: 
    если нет, то переходим к п.6;</li>
  <li>Запоминаем текущий номер вершины и переходим к одной из смежных (помечен-ных 
    белым цветом);</li>
  <li>Переходим к п.2;</li>
  <li>Помечаем текущую вершину черным цветом, выводим на печать номер вершины 
    и переходим к сохраненной ранее в п.4 вершине. Если таковой нет, значит, мы 
    прошли по всем вершинам графа и вернулись к исходной, иначе – повторить шаги 
    с п.2.</li>
</ol>
<p>На рисунке 4 показан процесс обхода графа, представленного списком смежных 
  вер-шин (рис. 2). За стартовую принята вершина 1.
</p>
<p><img src="img/11Lab_Ris4.GIF" width="625" height="219"></p>
<p>Рис. 4 – Пример обхода графа</p>
<p>Результат: 3, 4, 5, 2, 1.</p>
<h3 align="center">2 ВЫПОЛНЕНИЕ РАБОТЫ</h3>
<p>Изобразите граф в виде диаграммы: создайте машинное представление графа в виде 
  списочной структуры и в виде матрицы.</p>
<p>Составьте и реализуйте алгоритм обхода всех вершин графа (выведите на экран 
  спи-сок вершин в порядке обхода графа). </p>
<p>В приложении А находятся примеры представления графа и примеры функций обхода 
  графа.
</p>
<h3 align="center">ПРИЛОЖЕНИЕ А</h3>
<p>Примеры</p>
<pre>//Константы для обозначения цветов вершин<br>const int WHITE = 0; //white - белый цвет<br>const int GRAY  = 1; //gray - серый<br>const int BLACK = 2; //black - черный</pre>
<p>// -===== Представление в виде списка =====-<br>
  //Элементы списка объявляются в виде структуры<br>
  typedef struct<br>
  {<br>
  int num; //номер вершины<br>
  bool last; //является ли данная вершина последней в списке<br>
  }LIST;</p>
<p>//Строки массива (списки смежных вершин)<br>
  LIST list0[] = { {1,false}, {4,true} };<br>
  LIST list1[] = { {0,false}, {4,false}, {3,false}, {2,true} };<br>
  LIST list2[] = { {1,false}, {3,true} };<br>
  LIST list3[] = { {4,false}, {1,false}, {2,true} };<br>
  LIST list4[] = { {0,false}, {1,false}, {3,true} };</p>
<p>//Главный массив вершин, содержащий списки смежных вершин<br>
  LIST* arr[5] = {list0, list1, list2, list3, list4};</p>
<p>// -===== Представление в виде матрицы смежности =====-<br>
  int matrix[5][5] = {<br>
  { 0, 1, 0, 0, 1 },<br>
  { 1, 0, 1, 1, 1 },<br>
  { 0, 1, 0, 1, 0 },<br>
  { 0, 1, 1, 0, 1 },<br>
  { 1, 1, 0, 1, 0 }<br>
  };</p>
<p>//Все вершины перед началом обхода окрашены в белый цвет<br>
  int colors[5] = {WHITE, WHITE, WHITE, WHITE, WHITE};</p>
<p>// -====== Процедура обхода графа, представленного списком смежных вершин ======-<br>
  void ScanGraphList(int list_x) //номер вершины (в списке arr)<br>
  {<br>
  int counter = 0;</p>
<p> colors[ list_x ] = GRAY;</p>
<p> LIST* list = arr[list_x];<br>
  do<br>
  {<br>
  if(colors[ list[counter].num ] == WHITE)<br>
  {<br>
  ScanGraphList(list[counter].num);<br>
  }<br>
  }<br>
  while(list[counter++].last == false);</p>
<p>colors[ list_x ] = BLACK;<br>
  printf(&quot;%d &quot;, list_x);<br>
  }</p>
<p>// -====== Процедура обхода графа, представленного матрицей смежности ======-<br>
  void ScanGraphMatrix(int list_x, int num_count) //номер текущей вершины и общее 
  число вершин<br>
  {<br>
  int counter = 0;</p>
<p> colors[ list_x ] = GRAY;</p>
<p> for(int i=0; i&lt;num_count; i++)<br>
  {<br>
  if(matrix[list_x][i] &gt; 0 &amp;&amp; colors[i] == WHITE)<br>
  {<br>
  ScanGraphMatrix(i, num_count);<br>
  }<br>
  }</p>
<p> colors[ list_x ] = BLACK;<br>
  printf(&quot;%d &quot;, list_x);<br>
  }<br>
</p>
</pre>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Лекция №8.htm">Вернуться на лекцию</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
