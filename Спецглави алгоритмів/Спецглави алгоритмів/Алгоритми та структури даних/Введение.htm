<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center"><strong>Лекция №1</strong> </h2>
<h2 align="center"><strong>Введение</strong> </h2>
<p> Процесс создания компьютерной программы определяется не только этапами ее 
  создания, но еще и стилем программирования. В настоящее время широко используется 
  процедурный, декларативный и обьектно-ориентированный стили. При любом стиле 
  программирования выполняется анализ задачи и построение модели, в соответствии 
  с которой составляется программа. Под моделью понимаются математические зависимости, 
  схемы, описание операций и их последовательности при решении задачи и т.д. Рассмотрим 
  стили программирования и их принципиальные отличия друг от друга на конкретном 
  примере.</p>
<p><br>
  Пример. Пусть имеется набор данных, Представляющий родителей и их детей, А также 
  некоторую информацию о детях. Например: Иван – отец Алексея, Петр – отец Игоря 
  и Анны, Анна – женщина, Игорь – мужчина и т.д. Решение задачи состоит в том, 
  чтобы ответить на вопрос “Кто является сестрой указанного конкретного лица?”.</p>
<h3> Алгоретмический стиль решения.</h3>
<p>Он состоит в том, чтобы построить структуры данных и указать последовательность 
  операций на них. Решение указанной задачи состоит в том, чтобы найти потомка 
  – женщину, которая имеет того же родителя, что и указанное в запросе лицо. </p>
<p><br>
  Пусть исходная информация сосредоточена в двух матрицах РОДИТЕЛЬ (табл. 1) и 
  ПОЛ(табл. 2). Строки матрицы родитель обозначены именами родителей, а столбцы 
  именами детей; в матрице пол указаны имена и их пол. </p>
<p>Таблица 1. Родитель:</p>
<table width="400"  border="2">
  <!--DWLayoutTable-->
  <tr> 
    <td width="75"></td>
    <td width="75">Игорь</td>
    <td width="75">Анна</td>
    <td width="75">Алексей</td>
    <td width="75">…</td>
  </tr>
  <tr> 
    <td>Иван</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td></td>
  </tr>
  <tr> 
    <td>Петр</td>
    <td>1</td>
    <td>1</td>
    <td></td>
    <td></td>
  </tr>
  <tr> 
    <td>…</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
<p>Таблица 2. Пол:</p>
<table width="400"  border="2" >
  <!--DWLayoutTable-->
  <tr> 
    <td width="75">Имя</td>
    <td width="75">Игорь</td>
    <td width="75">Анна</td>
    <td width="75">Алексей</td>
    <td width="75">…</td>
  </tr>
  <tr> 
    <td>Пол</td>
    <td>муж.</td>
    <td>жен.</td>
    <td>Муж.</td>
    <td> </td>
  </tr>
  </table>
<p>Алгоритм решения задачи состоит в следующей последовательности операций: </p>
<OL type="1">
  <LI> По заданному имени X в столбце матрицы РОДИТЕЛЬ отыскивается имя Y – родителя 
    икса (по значению ‘1’);<br>
  <LI> По найденному Y просматривается строка с таким обозначением и ищется имя 
    Z ;<br>
  <LI> Если значение РОДИТЕЛЬ[X,Y] = ‘1’ , то имя Z проверяется в матрице ПОЛ 
    на значение “женщина”, и при положительном ответе имя Z выдается в качестве 
    результата. Так, при X = ‘Игорь’, результат Z = 'Анна'.<br>
</ol>
<h3>Декларативный стиль решения.</h3>
<p>Здесь выделяются ключевые абстракции, которые представляются Формулами логики 
  предикатов. Эти формулы записываются в специальном виде, называемом хорновскими 
  дизюнктами. Вопрос так же формируется как предикат. Процесс решения состоит 
  в доказательстве того, что вопрос является логическим следствием посылок. В 
  процессе доказательства запоминаются имена, которые являются значениями аргументов 
  (термов) предиката. Среди этих имен находится результат.</p>
<p>Продемонстрируем процесс решения задачи о нахождении сестры. При этом будем 
  использовать следующие абстракции:</p>
<li>Родитель (X,Y) – X является родителем игрока;</li>
<br>
<li>Женшина (X) – X является женщиной;</li>
<br>
<li>Неравно (X,Y) – X не равно Y.</li>
<p>Более сложная абстракция – определение сестры как переменной, имеющей общего 
  родителя с заданным лицом, характеристикой “женщина”, и которая отлична от самой 
  себя. Знак “:-” можно трактовать как определение абстракции, находящейся слева 
  от этого знака через абстракции, находящиеся справа.<br>
  Сестра(X,Y): - родитель(Z,X), родитель(Z,Y), женщина(X), не равно(X,Y), где 
  сестра(X,Y) обозначает, что X, является сестрой Y – ка.<br>
</p></p>
<p>Исходя из формулировок задачи, можно записать абстракции следующим образом:<br>
<li>(1) родитель (Петр, Анна)</li>
<br>
<li>(2) родитель (Петр, Игорь)</li>
<br>
<li>(3) родитель (Иван, Алексей)</li>
<br>
<li>(4) женщина (Анна)
<li>(5) не равно (Анна, Игорь)</li><br>
  <li>(6) сестра(X,Y) :- родитель(Z,X), родитель(Z,Y), женщина(X), не равно(X,Y).</li><br>
  <li>(7) сестра(X,Игорь)?</li><br></p>
</li> 
<p>Логический вывод состоит в том, чтобы на основе заданных абстракций (1) – (7) 
  вывести цепь логических следствий. На каждом шаге вывода отображается одна абстракция 
  с сохранением значений некоторой переменной. Вывод состоит в последовательности 
  следующих строк:<br>
</p>
<p>(8) сопоставляя вопрос (7) с (6), потому что только там находится абстракция 
  “сестры”, мы заключаем, что Y= ’Игорь’, и отбрасывая обстракцыю “сестра” получаем: 
  родитель(X,Y), родитель(Z,Игорь), женщина(X), не равно(X,Игорь).<br>
</p>
<p>(9) начальной целью является цель в строке (7). Строка (8) задала последовательность 
  текущих целей (Родитель, родитель, жена, не равно). Сопоставляя текущую цель 
  родитель (Z,X), из (8) и (1) имеем: Z = ‘Петр’, X = ‘Анна’. Отбрасывая рассмотренную 
  цель, имеем: родитель (Петр, Игорь), женщина (Анна), не равно (Анна, Игорь).<br>
</p>
<p>(10) из (9) и текущей цели родитель (Петр, Игорь), и (2) имеем: женщина (Анна), 
  неравно (Анна, Игорь)<br>
</p>
<p>(11) из (10) и (4) имеем: неравно (Анна, Игорь)<br>
</p>
<p>(12) из (11) и (5) получаем, пустую строку, что обозначает, что доказательство 
  логического следствия завершено успешно.<br>
</p>
<p>Так как в (7) вопрос заключался в значении переменной X, то, вернувшись к шагу 
  (9), мы получаем X ='Анна', что и является ответом.<br>
</p>
<h3>Обьектно – ориентированный стиль решения.</h3>
<p>При обьектно – ориентированном (О.О.) стиле программирования используются как 
  элементы декларативного стиля (выделение кончептуальных абстракций, называемых 
  классами и обьектами), так и элементы процедурного программирования (методы). 
  Элементами О.О. парадигмы являются: класс, обьект, наследование, метод, сообщение. 
  Сообщения управляют работой обьектов.<br>
</p>
<p>Исходной парадигмой О.О. стиля является высказывание: ”представь программу 
  в виде совокупности объектов, каждый из которых является реализацией некоторого 
  класса, а классы образуют иерархию на принципах наследуемости”. Класс как раз 
  и является абстракцией реального мира.<br>
</p>
<p>В процедурном подходе при составлении программы сначала определяются структуры 
  данных, которые затем передаются в процедуры как параметры. Кроме того, программа 
  диктует пользователю последовательность действий для достижения результата. 
  При О.О. подходе программы управляются событиями, позволяя пользователю диктовать 
  программе те или иные шаги.<br>
</p>
<p>Говоря о рассмотренном выше примере родственных отношений можно в качестве 
  абстракций выделить: ”родитель”, ”сестра”, ”дополнительные сведения”, установить 
  между ними взаимоотношения, определить события, определить методы (функции), 
  манипулирующие данными.<br>
</p>
<p>Какой бы стиль программирования ни избрать, нужно помнить, что машинный эквивалент 
  программы – это алгоритм. При процедурном подходе мы сразу избираем алгоритм 
  для построения программы. В декларативном подходе алгоритм для интерпритации 
  всех логических программ един. Чтобы лучше понимать декларативную и процедурную 
  составляющие декларативного стиля, необходимо знать, как функционирует этот 
  алгоритм и какова его структура.<br>
</p>
<p>При О.О. – подходе алгоритм всегда неявно подразумевается при определении методов 
  и управлении объектами при помощи событий.<br>
</p>
<p>Выше изложенное позволяет утверждать, что алгоритм есть функциональное понятие 
  дисциплины программирования и умение строить алгоритмы – неотъемное умение алгоритма.<br>
</p>
<p>При решении одной и той же задачи может существовать несколько алгоритмов, 
  и нужно уметь выбрать оптимальный. Понятие оптимального алгоритма зависит от 
  предъявляемых требований. Например, наиболее короткая запись в языке представления 
  алгоритмов, или минимальное время выполнения алгоритма, или наименьший рост 
  времени от объема входных данных. Оптимальный алгоритм определяется в процессе 
  его анализа.<br>
</p>
<p>Рассмотрим пример. Пусть необходимо составить алгоритм для вычисления значения<img src="img/1vRis1.GIF" width="153" height="70"> 
  при заданном n. Первый из алгоритмов, приходящих на ум, состоит в суммировании 
  слагаемых (-1)<sup>i</sup>*i при изменении i от 1 до n. Назовем этот алгоритм 
  А1 и реализуем его в качестве цикла “for”: </p>
<p>(А1) <br>
  y=0<br>
  for i=1 to n<br>
  do y=y+(-1)^i*i.<br>
</p>
<p>Где for i=1 to n обозначенный цикл суммирования под управлением переменной 
  i, изменяющейся от 1 до n с шагом 1. Этот алгоритм представлен в каскадоподобном 
  коде (о псевдо, кодах речь пойдет дальше). Анализируя этот алгоритм, замечаем, 
  что здесь использованы операции ^ (возведение в степень) и * (умножение), которые 
  требуют относительно много (по отношению к +) времени для своего выполнения.<br>
</p>
<p>Внимательно посмотрев на формулу для вычисления y, замечаем, что (-1) в в нечетной 
  степени дает (-1) а в четной – (1). Поэтому можно избавится от операций ^ и 
  *. В этом случае при четном i необходимо суммировать слагаемые i, а при нечетном 
  – вычитать i. Такой подход реализуется в алгоритме А2, где имеются два цикла 
  с шагом 2. В первом цикле на каждом шаге к имеющейся сумме прибавится i. Во 
  втором шаге при каждом шаге вычитается i. <br>
</p>
<pre><p>А2.
  y=0
  for i=2 step 2 to n
        do y=y+i
  for i=1 step 2 to 
        do y=y-i
</p></pre>
<p>Если обозначить время выполнения А1 через t1, а время выполнения А2 – через t2, 
то при n=2000 и быстродействии ЭВМ 10<sup>6</sup> операций/секунду получим t2=0.05t1. Налицо
 существенный выигрыш во времени при выборе алгоритма А2. Можно составить третий 
 вариант вычисления y. Заметим, что при n-четном получаем две последовательности 
 S1=1+3+…+n-1 и S2=2+4+…+n, которые являются арифметическими прогрессиями. Сумма 
 арифметической прогрессии определяется формулой S=(a1+an )/2*n (а1 – первый член 
 прогрессии, an –  последний, n – количество членов последовательности). При n – четном 
 количество членов в S1 и S2 равняется n/2. Поэтому S1=(1+n-1)/2*n/2=2n/4, 
 S2=(2+n)/2*n/2=n<sup>2</sup>+2n/4, y=S2-S1=(n<sup>2</sup>+2n)/4-n<sup>2</sup>/4=n/2.</p>
<p>При n – нечетном количество членов в S2 равно (n-1)/2, а количество членов 
  в S1 – ((n-1)/2+1). Соответственно S1=(1+n)/2*((n-1)/2+1)=(n<sup>2</sup>+2n+1)/4=-(n+1)/2.</p>
<p>Таким образом, если n – четное, то y=n/2. В противном случае y=-(n+1)/2. В 
  виде алгоритма это можно выразить условным оператором.<br>
</p>
<p>А3: if n – четное then y=n/2 else y=-(n+1)/2.<br>
</p>
<p>Если алгоритмы А1 и А2 требуют при своей работе многократного повторения одних 
  и тех же операций, алгоритм А3 выполняется без повторов, что позволяет сказать 
  о наименьших затратах времени. Алгоритм А3 оказался оптимальным и с точки зрения 
  быстродействия, и с точки зрения компактности записи.<br>
</p>
<p>Рассмотрим теперь зависимость роста времени от объема входных данных. В данном 
  случае (А1, А2, А3) Обьем входнах данных характеризуется числом n.Время выполнения 
  А1 и А2 прямо пропорционально количеству выполняемых команд, которое, в свою 
  очередь, прямо пропорционально количеству циклов. Если увеличить n в l раз, 
  то и количество циклов увеличится в l раз, что позволит говорить о прямо пропорциональной 
  зависимости. Ниже приведены графики зависимостей T(время) от n(объем):<br>
</p>
<p><img src="img/1vRis3.GIF" width="601" height="194"></p>
<p>Из графиков видно, что <img src="img/alfa.GIF" width="18" height="15">2&lt;<img src="img/alfa.GIF" width="18" height="15">1. 
  <br>
</p>
<p>Из графиков видно, что в случае А3 время практически не растет с увеличением 
  n.<br>
</p>
<p>Зависимость T от n называется сложностью алгоритма. <br>
</p>
<p>Дисциплина “Конструирование и анализ алгоритмов” посвящена методам построения 
  и нахождения сложности алгоритмов.
<p>Контрольные вопросы.<br>
<ol>
  <li>Чем отличается алгоритмический стиль программирования от декларативного?</li>
  <li>Дайте характеристику декларативного стиля программирования.</li>
  <li>Назовите языки различных стилей программирования.</li>
  <li>Какими свойствами характеризуется алгоритм?</li>
  <li>Что называется сложностью алгоритма?<br>
    <br>
  </li>
</ol>
<p></p>
<p></p>
<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
