<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция №9</h2>
<h2 align="center">Тема. СТРУКТУРА ДАННЫХ</h2>
<p>&nbsp;</p>
<h3 align="center">СТРУКТУРА ДАННЫХ</h3>
<p>Задачи реального мира, которые решаются с помощью ЭВМ нуждаются в создании 
  алгоритмов. Алгоритмы обрабатывают данные, которые имеют разнообразный характер. 
  Алгоритм обработки данных в значительной степени зависит от формы представления 
  этих данных. Организация данных для обработки является важным этапом разработки 
  алгоритмов. Одни и те же самые операции с разными структурами (форма организации 
  данных) создают алгоритм разной эффективности. Структура данных не является 
  пассивным обектом: необходимо принимать во внимание выполняемые с ней операции 
  и алгоритмы, которые используются для этих операций. Существуют базовые принципы 
  организации данных для использования их в алгоритмах. Эти принципы формально 
  отображены в понятии типов данных. Существует понятие абстрактного типа данных 
  (АТД), где описание тип отделен от его реализации (алгоритма). Классические 
  структуры данных - это массивы, связнные списки, ленты. Они реализуются с помощью 
  деревьев. Используются также составные структуры, такие как массивы связанных 
  списков и массивы массивов. Дополнительные возможности для обработки типов и 
  структур- указатель. Благодаря ним в состав структур возможно включать лишь 
  ссилки на данные, которые сохраняются отдельно.</p>
<p>Данные, которые обрабатывает алгоритм, возможно интерпретировать как множества, 
  представленные разными структурами данных. В процессе выполнения алгоритма данные 
  изменяются, т.е. отображаются динамическими(изменяющимися) множествами.</p>
<p>Над элементами множеств выполняются операции, которые изменяют множества. Операции 
  над множествами приведено ниже.</p>
<p>SEARCH (S, k) - поиск; за данным множеством S и ключом k (идентификатор элемента) 
  находится элемент.</p>
<p>INSERT (S, x) - прибавляет к множеству S элемент, на который указывает указатель 
  x.</p>
<p>DELETE (S, x) - удаляет из множества S элемент, на который указывает указатель 
  х.</p>
<p>Обратите внимание, што х - указатель, а не ключ.</p>
<p>MINIMUM (S) - выдает указатель на элемент множества S с наименьшим ключом.</p>
<p>MAXIMUM (S) - выдает указчик на элемент множества S из наибольшим ключом.</p>
<p>SUCCESSOR (S, x) - выдает указатель на элемент множества S, что подражает х. 
  Если х - „наибольший” элемент, возвращается NILL.</p>
<p>PREDECESSOR (S, x) - выдает указатель на элемент множества S, что передует 
  х. Если х - „наименьший” элемент, возвращается NILL.<br>
</p>
<h3 align="center">СТЕКИ И ОЧЕРЕДИ. </h3>
<p>Это структуры данных, в которых DELETE (S, x) задается не произвольно, а определяется 
  структурой множества. Т.е. “х” не надо указывать. Принцип работы стека “последним 
  пришел - первым пошел”; очереди - “первым пришел - первым пошел”. Стек и очередь 
  реализуются с помощью масива.</p>
<p>Операция добавления элемента в стек обозначается как PUSH, а операция удаления 
  - как POP. Стек может быть пустым или переполненным. Операции проверки пустоты, 
  добавление элемента, удаление элемента приведены ниже.</p>
<pre>STACK _Empty (S)
1	if top [S]=0
2	     then return TRUE 
3	     else return FALSE
</pre>
<p>top [S] - число, которое сохраняется вместе с массивом S. Если top [S]=0, стек 
  пустой (is empty). </p>
<pre>PUSH (S, x)
      1        top [S] ( top [S]+1
      2        S [top [S]](x
</pre>
<pre>
POP (S)
1	if STACK_Empty (S)
2	         then error “стек пустой”
3	         else top [S] ( top [S] - 1 
4	                return S [top [S]+1]
</pre>
<p>Операцию добавления элемента к очереди обозначим как ENQUEUE, а операцию удаления 
  – DEQUEUE. У очереди есть голова (header) и хвост(tail). Если Q – массив, который 
  определяет очередь, head[Q] – индекс главы очереди, tail[Q] – индекс свободной 
  ячейки, куда надо расположить добавляемый к очереди элемент, а элементы размещены 
  в ячейках с индексами head[Q], head[Q]+1 ,…, tail[Q]-1 (рассматривается случай 
  масива, свернутого в кольцо - за n следует 1). Если head[Q]=tail[Q] - очередь 
  пустая. Сначала head[Q]=tail[Q]=1. Если очередь пустая, выделение из нее элемента 
  ведет к ошибке Если head[Q]=tail[Q]+1, очередь заполненная полностью и добавление 
  элемента к ней ведет к ошибке. В алгоритмах ENQUEUE i DEQUEUE, приведенных ниже, 
  игноруется возможность переполнения и пустоты очереди</p>
<pre>ENQUEUE(Q,x)
1	Q[tail[Q]](x
2	If tail[Q]=length[Q]
3	    then  tail[Q](1
4	    else tail[Q](tail[Q]+1</pre>
<pre>
DEQUEUE (Q)
1	x(Q[head[Q]]
2	if head[Q] =length[Q]
3	     then head[Q](1
4	     else head[Q](head[Q]+1
5	return x
length[Q] - количество элементов(максимальная) масива Q.<br></pre>
<h3 align="center">СВЯЗНЫЕ СПИСКИ</h3>
<p>В связном списке элементы линейно благоустроены, но их порядок определяется 
  не номерами, как в массиве, а указчиками, которые входят в состав элементов 
  списка. Списки есть удобный способ сохранения динамических множеств, которое 
  разрешает реализовывать все операции на множествах. Различают односторонние 
  списки, где каждый предыдущий элемент указывает на следующий, и двусторонние, 
  где дополнительно к одностороннему, каждый следующий элемент указывает на предыдущий.</p>
<p>Элемент двустороннего связного списка - это запись, которая имеет три поля: 
  key (ключ) и два указчика - next (следующий) и prev (previous - предыдущие). 
  Кроме этого элементы списка могут содержать в себе дополнительные данные. Если 
  х - элемент списка, то next[x] показывает следующий элемент,а prev[x] - предыдущий. 
  Если prev[x] = NILL, то у элемента х нет предыдущего: это начало списка (head). 
  Если next[x] = NILL, то х - последний элемент списка, или его хвост (tail).</p>
<p>Прежде чем продвигатся по указателям, надо знать хотя бы один элемент списка. 
  Предположим, что для списка L мы знаем указатель head[L] на его начало. Если 
  head[L] = NILL, список пустой.</p>
<p>В односторонне связанном списке отсутствует поле prev. В благоустроенном списке 
  элементы расположены в порядке роста ключей: начало списка имеет наименьший 
  ключ, а хвост - наибольший, в отличие от упорядоченного. В кольцевом списке 
  поле prev начала списка указывает на хвост списка, а поле next хвоста списка 
  указывает на начало.</p>
<p>Если не оговорено особенностей, под списком будем понимать неупорядоченный 
  двухсторонне связанный список.</p>
<p>На рисунке (а) показан связанный список, который содержит числа 1,4,9,16; на 
  (б) - список, полученный из предыдущего путем добавления в начало списка элемента 
  25; на (в) - список, полученный из предыдущего путем удаления элемента с ключом 
  4 (Рис.1).</p>
<p align="center"><img src="img/9vRis1.GIF" width="675" height="266"></p>
<p align="center">Рис.1. (а), (б), (в). Пример списков </p>
<h3>Поиск в списке.</h3>
<p>Процедура LIST_SEARCH(L,k) находит в списке L первый элемент, который имеет 
  указатель на этот элемент или NILL, если элемента с таким ключом нет.</p>


<pre>LIST_SEARCH(L,k)
1	x ( head[L]
2	while x ( NILL and key[x] ( k
3	 	do x ( next[x]
4	return x</pre>
<h3>Добавление элемента в список.</h3>
<p>Процедура LIST_INSERT прибавляет элемент х к списку L, располагая его в начале 
  списка.</p>
<pre>LIST_INSERT(L,x)
1	next[x] ( head[L]
2	if head[L] ( NILL
3	    then prev [head[L]](x
4	head[L](x
5	prev[x](NILL</pre>
<h3>Удаление элемента со списка.</h3>
<p>Процедура LIST_DELETE удаляет элемент х из списка L, направляя показатель “в 
  обход” этого элемента. При этом в качестве аргумента ей передается указчик на 
  х. Если задан ключ элемента х, то перед удалением надо его указчик с помощью 
  процедуры LIST_SEARCH.<br>
</p>
<pre>LIST_DELETE(L,x)
1	if prev[x](NILL
2	    then next[prev[x]](next[x]
3	    else head[L](next[x]
4	if next[x](NILL
5	   then prev[next[x]](prev[x]
</pre>
<h3>&nbsp;</h3>
<h3>Контрольные вопросы.</h3>
<ol>
  <li>Стек разрешает прибавлять и удалять элементы только с одной стороны. В очереди 
    прибавлять элементы можно с одной стороны, а удалять с другой. Структура данных 
    дек (очередь с двумя концами) разрешает прибавлять и удалять элементы с обеих 
    концов. Составьте алгоритм реализации дека на базе массива.</li>
  <li>Составьте алгоритм реализации очереди на базе двух стеков. Оцените время 
    работы операций ENQUEUE и DEQUEUE при этой реализации. Сравните это время 
    и время для этих же операций, алгоритмы которых приведены выше.<br>
    ( Указание: в первый стек ( S1) последовательность элементов записывается 
    в прямом порядке, во второй стек (S2) - в обратном; ENQUEUE реализуется как 
    PUSH(S1,x), DEQUEUE как POP(S2)).</li>
  <li>Покажите,что для списка из n элементов поиск в списке (LIST_SEARCH) имеет 
    в наиболее плохом случае сложность Ө(n); LIST_INSERT-О(1); LIST_DELETE-В 
    (1); LIST_DELETE с заданным ключом - Ө(n).</li>
  <li>Реализуйте стек на базе односторонне связаного списка.Операции PUSH и POP 
    должны выполняться за время О(1).</li>
  <li>Напишите процедуру, которая сливает два односторонне связанных упорядоченных 
    списки в один (тоже упорядоченный).<br>
  </li>
</ol>
<p>&nbsp;</p>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="ПЗ №1.htm">Практическое занятие №1. ДЕРЕВЬЯ</A><P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="ПЗ №2.htm">Практическое занятие №2. ГРАФЫ.</A><P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="Лаб №3.htm">Лабораторная работа №3. Создание графов и обход вершин.</A><P>

<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
