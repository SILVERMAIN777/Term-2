<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
<h2 align="center">Лекция № 3</h2>
<h2 align="center">Тема: Модели для конструирования алгоритмов. Языки представления 
  алгоритмов.</h2>
<p>Основой для конструирования алгоритмов является модель, определяющая операции 
  и порядок их выполнения. Все операции алгоритма представляются записью в некотором 
  языке. Наиболее простые модели – это базовые модели для нахождения сумм и произведений. 
  Чтобы вычислить сумму <img src="img/3vRis1.GIF" width="96" height="78">, необходимо 
  определить начальное значение y, присвоив ему значение о.Затем циклически находить 
  y=y+x<sub>i</sub> , где i изменяется от 1 до n.</p>
<p>Рассмотрим представление алгоритмов для вычисления суммы и произведения на 
  языке блок-схем. Здесь используются вычислительные блоки (прямоугольник), внутри 
  которого записываются выполняемые операции, и управляющие блоки (ромбы), внутри 
  которых записываются условия. Порядок выполнения блоков указывается стрелками. 
  Другие обозначения блоков (кроме указанных) и правила рисования блок-схем описаны 
  в [1].</p>
<p>Алгоритм для вычисления <img src="img/3vRis1.GIF" width="96" height="78">:</p>
<p align="center"><img src="img/3vRis2.GIF" width="425" height="402"></p>
<p align="center">&nbsp;</p>
<p>Операции нахождения суммы (y=y+x<sub>i</sub>) и изменения индекса (i=i+1) составляют тело 
  цикла. Операция i&lt;=n управляет повторениями цикла. Заметим, что эта операция 
  здесь стоит перед телом чикла. Если поставить операцию управления циклом после 
  тела цикла, то алгоритм приобретет вид:</p>
<p align="center"><img src="img/3vRis3.GIF" width="229" height="389"></p>
<p>Алгоритм для вычисления <img src="img/3vRis4.GIF" width="99" height="81">:</p>
<p align="center"><img src="img/3vRis5.GIF" width="322" height="406"></p>
<p>Обычно разработка алгоритма ведется “сверху-вниз”, т.е. от общего к частному. 
  Блок-схема в явном виде не соответствует этому правилу разработки. Для соответствия 
  языка представления алгоритма способу разработки “сверху-вниз” применяют язык 
  программных деревьев. В языке программных деревьев используются три стандартных 
  блока: следование, выбор, цикл. Графическое представление этих блоков:<br>
  
<li>Следствие (рис1.1). Здесь порядок выполнения слева направо.</li>
<br>
  
<li>Выбор (рис1.2). Порядок выполнения: если “условие” истина, выполняется “оператор 
  1”, в противном случае - “оператор 2”.</li>
<br>
  
<li>Цикл (рис1.3). Порядок выполнения: если “условие” истина, то выполняется “оператор 
  ”, иначе выполнение цикла прекращается.</li>
<br></p>
<p align="center"><img src="img/3vRis6.GIF" width="303" height="167"></p>
<p align="center">Рис1.1. Следствие. </p>
<p align="center"><img src="img/3vRis7.GIF" width="361" height="219"></p>
<p align="center">Рис1.2. Выбор.</p>
<p align="center"><img src="img/3vRis8.GIF" width="290" height="226"></p>
<p align="center">Рис1.3. Цикл.</p>
<p>Ниже приводятся алгоритмы, представленные на языке программных деревьев.</p>
<p>Алгоритм вычисления НОД (х, у), модель которого приведена в лекции 1:<br>
  <br>
  <img src="img/3vRis9.GIF" width="454" height="420"> </p>
<p>Алгоритм нахождения максимального числа в последовательности x<sub>i</sub>, 1&lt;=i&lt;=n:</p>
<p><img src="img/3vRis10.GIF" width="494" height="496"></p>
<p>Алгоритм является промежуточной структурой при составлении программы. Поэтому 
  желательно, чтобы запись алгоритма была как можно ближе к записи программы. 
  В качестве языка представления алгоритма чаще всего выбирают псевдокод, который 
  является аналогом языка программирования. Разница между псевдокодом и языком 
  программирования заключается в том, что первый предназначен для понимания человеком, 
  а второй программой транслятором. Псевдокод похож на язык программирования, 
  например Паскаль и Си. Мы будем использовать паскалевский псевдокод [2]. Ниже 
  перечисляются соглашения, использующиеся для псевдокода.</p>
<ol>
  <li> Оператор присваивания у<img src="img/ctrelka_v_levo.GIF" width="22" height="14">х 
    (переменной у присвоить значение переменной х).</li>
  <li>Циклы: 
    <pre>For i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1 to n
          do &lt;тело цикла&gt;</pre>
    тело цикла выполняется n раз с проверкой в начале цикла и с шагом 1. Если 
    шаг не 1, выводится<br>
    <pre>step (for i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">1 step 2 to n)
    while &lt;условие&gt;
         do &lt;тело цикла&gt;</pre>
    тело цикла выполняется пока &lt;условие&gt; истинно.</li>
  <li>Оператор выбора:<br>
    <pre>If&lt;условие&gt; then&lt;оператор&gt;
    If&lt;условие&gt; then&lt;оператор 1&gt; else&lt; оператор 2&gt;.</pre>
    Если &lt;условие&gt; истинно, то выполняется &lt;оператор&gt; или &lt;оператор 
    1&gt;. В противном случае выполняется &lt; оператор 2&gt;или следующий за 
    If оператор.</li>
  <li>Элемент массива записывается как А[i, j], где А – имя массива, i, j – индексы. 
    Обозначение А[i..j] обозначает участок массива А[i], А[i+1],…, А[j]. </li>
  <li>При обращении к процедуре параметры передаются по значению.<br>
    В дальнейшем изложении будет использоваться псевдокод для записи алгоритмов. 
    Употребление каких-либо не отмеченных выше свойств и операторов языка будет 
    поясняться.</li>
</ol>
<p>Рассмотрим в качестве примера применение псевдокода составление алгоритма сортировки 
  вставками. Задача сортировки предполагает, что задана последовательность чисел, 
  которую нужно упорядочить по возрастанию. Например: 3,1,2,1,5,4 результат 1,1,2,3,4,5.</p>
<p>Алгоритм сортировки вставками удобен для сортировки коротких последовательностей. 
  Пусть исходные данные расположены в массиве A[1..n]. Мы будем обозначать число 
  элементов в массиве А через length[A], что представляет длину массива как атрибут 
  объекта А. Употребление квадратных скобок создает коллизию с обозначением массива, 
  но мы будем различать атрибут объекта и массив по контексту их употребления.</p>
<p>Сортировка вставками производится “на месте”, т.е. в массиве А без привлечения 
  дополнительной памяти. Начиная со второго элемента массива, в цикле просматриваются 
  слева направо все элементы массива. Для текущего элемента устраивается просмотр 
  с элементами, расположенными левее и сдвижка текущего элемента влево до нахождения 
  его места среди левых элементов. Здесь ниже приведен пример выполняемых операций 
  и их результаты(рис.2).</p>
<p>Пусть A=&lt;5,2,4,6,1,3&gt;.</p>
<p align="center"><img src="img/3vRis11.GIF" width="307" height="264"></p>
<p align="center">Рис.2.Выполняемые операции при сортировке вставками.</p>
<p>Позиция текущего элемента показана кружком. Этот элемент сдвигается влево, 
  заменяя (сдвигая вправо) левые элементы.</p>
<p>Назовем алгоритм сортировки вставками Sort_Vstk. Его исходным данным является 
  массив А, и обозначение алгоритма есть Sort_Vstk(A).</p>
<p>Для организации цикла, просматривающего элементы слева на право, применим цикл 
  for с известным числом повторений и управляющей переменной j. Для организации 
  цикла, просматривающего элементы справа налево, используем цикл while (с заранее 
  неизвестным числом повторений), который управляется условием, пока истинно утверждение, 
  что текущий элемент меньше просматриваемого левого и при движении влево не вышли 
  за левый край массива. Для организации сдвижки элементов массива вправо используется 
  память key, где хранится текущий элемент. Индекс массива А при движении влево 
  обозначим через i.</p>
<pre>  Sort_Vstk(A).
1	for j<img src="img/ctrelka_v_levo.GIF" width="22" height="14">2 to length[A]
2	do key<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[j]
3			i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">j-1
4			while i&gt;0 and A[i]&gt;key
5				do A[i+1]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">A[i]
6					i<img src="img/ctrelka_v_levo.GIF" width="22" height="14">i-1      
7			A[i+1]<img src="img/ctrelka_v_levo.GIF" width="22" height="14">key</pre>
<p>Операторы в псевдокоде будем нумеровать. Так строка 1 задает заголовок цикла 
  (просмотр влево), повторяющегося от 2 до n (количество элементов в А). Строка 
  2 освобождает ячейку для сдвижки элементов массива вправо. Строка 3 создает 
  индекс первого элемента массива слева от выбранного в цикле for. Строка 4 заголовок 
  цикла, работающего по условию. Строки 5 и 6 – тело цикла while. Строка 7 – это 
  запись элемента на свое место при движении влево.</p>
<p>Необходимо обратить внимание на отступы при написании оператора в строке. Они 
  указывают на вложенность операторов. Те операторы, которые имеют одинаковый 
  отступ – независимы (например, 3, 3, 4, 7). А оператор, у которого отступ больше 
  чем у верхнего, вложен в верхний (например, 5, 6 вложены в 4, который, в свою 
  очередь, вложен в 1).</p>
<p>Результат работы алгоритма Sort_Vstk(A). Будет находиться в А, которое указанно 
  в написании процедуры. Поэтому возвращать значение (оператор return) в этом 
  алгоритме не нужно.</p>
<p>Контрольные вопросы.</p>
<ol>
  <li> Какую роль играет модель при конструировании алгоритма?</li>
  <li>Составьте алгоритм нахождения максимального элемента в последовательности 
    с неизвестным количеством элементов на языке блок – схем.</li>
  <li>На языке программных деревьев составьте алгоритм нахождения минимального 
    элемента матрицы размером m*n.</li>
  <li>На псевдокоде составте алгоритм сортировки, аналогичный приведенному, но 
    сортирующий справа – налево (от большего элемента).</li>
  <li>На псевдокоде составьте алгоритм поиска заданного элемента (a<sub>k</sub>) в последовательности 
    из a<sub>1</sub>, a<sub>2</sub>,…,a<sub>n</sub>. <br>
    <br>
  </li>
</ol>
<p>&nbsp;</p>
<P><br>
<font color="#481493" size="3" face="arial">
&copy, 2004, ХНУРЭ, каф. ПОЭВМ, Дюбко Г. Ф., все вопросы направлять по адресу: Valenda@ukr.net</font></p>
<p>&nbsp;</p>
</body>
</html>
